   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



                             GRAPHICS I/O DESIGN
                                  Doug Tody
                                December 1984
                            (revised October 1987)
   
   
   
   
   
   1. INTRODUCTION
   
       The  graphics  i/o  (GIO)  interface  is a library of SPP or Fortran
   callable procedures for interactive vector graphics.  The  interface  is
   designed  primarily  for scientific applications (graphing 1-dimensional
   data  vectors).   Limited  support  is  also  provided  for   displaying 
   2-dimensional  image data.  GIO is fully integrated into the IRAF system
   and is not intended for use in systems other than IRAF.   The  principal
   design objectives of GIO are outlined below.
   
   
       o   Simple  and  efficient  interactive  graphics.   For interactive
           data  analysis  applications  speed  is  typically   much   more 
           important than the quality of the plot.
       
       o   Ease  of  use.  The interface must be easy to use for scientific
           data  analysis  applications.   Ease  of  use  for   interactive 
           graphics   in   scientific   applications   is  considered  more 
           important than the flexibility required to  produce  publication
           quality graphics.
       
       o   Compact  size.  That portion of the graphics system required for
           interactive graphics must be small  enough  to  be  linked  into
           every process which performs interactive graphics.
       
       o   Device  independence.   The interface must be device independent
           without  compromising  compactness  and  speed.    True   device 
           independence  means  that  an applications program that normally
           uses interactive graphics can be run noninteractively or from  a
           nongraphics workstation.
   
   
   IRAF  needs  its  own  graphics  interface  partly  because  no existing
   graphics interface meets all  of  the  above  requirements,  and  partly
   because  we  do  not  want  our  applications  to  be dependent upon any
   particular external  graphics  package.   The  existing  large  graphics
   interfaces  such  as  GKS  and  CORE  are  likely  to  make it easier to
   interface GIO  to  new  graphics  devices,  but  to  be  completely  and
   directly   dependent   on   any  one  such  interface  is  unwise  since 
   implementations are sometimes hard to come  by.   Furthermore,  packages
   such  as GKS and CORE were designed to serve as the kernel of a graphics
   system and are cumbersome to  use  directly  in  applications  software.
   GIO  will  serve  as  a  front  end  to the graphics kernel, providing a
   higher level interface for applications software and isolating the  IRAF
   applications  from  the  kernel,  making  it  possible  to  switch  to a
   different kernel without rewriting the applications packages.


                                     -1-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   2. CONCEPTUAL DESIGN
   
       GIO is intended to be used either as a self contained interface to a
   graphics  device,  with  GIO writing device instructions directly to the
   device, or  as  an  interface  to  a  more  general  device  independent
   graphics  kernel.   For  maximum  speed  in interactive applications GIO
   will  use  a  special  builtin  kernel  capable  of  driving  only   the 
   interactive  graphics  devices  in  use  at  a  particular  site  (e.g., 
   tektronix compatible graphics terminals).  Other devices will be  driven
   by   a  device  independent  graphics  kernel  resident  in  a  separate 
   process.  GIO will select the data path to  be  used  for  a  particular
   device  transparently  to  the  calling  program.  Thus, the overhead of
   process initiation and IPC will  be  eliminated  in  common  interactive
   applications  without  sacrificing  device  independence.   The  builtin 
   kernel will be table driven  using  a  TERMCAP  format  graphics  device
   database,  allowing maximum flexibility for adapting GIO to new graphics
   devices.
   
   The device independent graphics kernel may be GKS, CORE,  NSPP,  or  any
   other  reasonably  capable kernel.  GIO will be designed to require only
   a  few  simple  graphics  primitives  at  the  bottom  end,  making   it 
   straightforward   to  interface  to  different  graphics  kernels.   Any 
   application which requires a more sophisticated graphics interface  than
   that  provided by GIO may bypass GIO and talk directly to the underlying
   graphics kernel, but doing so will render the  application  usable  only
   with that particular graphics kernel.
   
   Placing  the  device  independent  graphics kernel in a separate process
   makes it possible to use a large, sophisticated graphics kernel  without
   linking  enormous  libraries of subroutines into applications processes.
   Bugs can be fixed and new features and devices added  without  relinking
   applications  processes.   In principle it is even possible to interface
   simultaneously to more than one graphics kernel, e.g., one  might  drive
   some  devices  with  an  NSPP kernel and others with a GKS kernel.  On a
   different host CORE might be the only  thing  available  and  GIO  would
   have to be interfaced to CORE on such a host.
   
   



















                                     -2-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



                   __________
                  /          \
                  | graphics |
                  | terminal |
                  \__________/
                      |  ^
                      |  |(device codes)
                      v  |                           _________
                   +--------+     +-----------+     /         \
                   |   CL+  |<----| graphics  |<----|         |
                   |  fast  |     |  kernel   |     | gdevice |
                   | kernel |---->|   task    |---->|         |
                   +--------+     +-----------+     \_________/
                      |  ^                 |
                      |  |(gki metacode)   |          (core metacode)
                      v  |                 +--------> (nspp metacode)
                   +--------+                         (gks vdm)
                   |  user  |
                   |  task  |-----------------------> (gki metacode)
                   +--------+
   
   
                     simple                   plotters
             |---  interactive ---|------     metafile    ------|
                    graphics               special devices
   
   
                      Figure 1. Graphics Task Structure
   
   
   The  IRAF  command  language (CL) is the user interface to IRAF programs
   and  as  such  moderates  all  interaction  with  the  user,   including 
   interaction  via  graphics  devices.  GIO is primarily a graphics OUTPUT
   interface; graphics input (other than pixel readback) is decoupled  from
   graphics  output and is controlled by the CL.  Often the task requesting
   cursor input will differ from that which  produced  the  graphics.   The
   CL,  under  control  of the user, may set the default graphics input and
   output devices, redirect graphics input and/or output to  devices  other
   than   the  default,  and  control  whether  a  graphics  task  is  used 
   interactively or in batch mode.
   
   
   
   3. SPECIFICATIONS
   
       The GIO graphics output procedures draw various flavors  of  vectors
   and  fill  or  color  two  dimensional  areas.  Cursor input is a way of
   interacting with the user and is therefore handled by CLIO (the  command
   language  interface).   We  first  define important terms and define the
   coordinate systems used by GIO.  Next follows an overview of  the  input
   and  output  procedures.   Finally, we describe in detail the individual
   procedures and the interface to the graphics kernel.
   
   
   


                                     -3-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.1 COORDINATE SYSTEMS
   
       The full  plotting  surface  of  a  device  defines  the  domain  of
   definition  of  the  coordinate systems used by GIO.  GIO supports up to
   sixteen user defined WORLD COORDINATE SYSTEMS  (WCS)  per  open  device,
   numbered  1  through  16.  One additional coordinate system (WCS 0) with
   values ranging from 0 to 1  in  either  axis  is  predefined  for  every
   device;  this  NORMALIZED  DEVICE COORDINATE SYSTEM (NDC) spans the full
   plotting surface of the device.
   
   The mapping of world coordinates to device coordinates is defined  by  a
   WINDOW  into  world  space  and  a  corresponding  VIEWPORT  into device
   space.   Each  window-viewport  pair  defines  one  of  the   16   world 
   coordinate  systems.   At  GOPEN time GIO is initialized to WCS 1, which
   has both window and viewport set to NDC coordinates.  A subsequent  call
   to  either GSWIND or GSCALE will set the window and a subsequent call to
   GSVIEW will set the viewport.  The WCS is not fixed to the device  until
   a  plotting  operation  occurs  which  requires  use of the WCS.  Hence,
   multiple calls to GSCALE to determine the range of data values in X  and
   Y  for  a  family  of  curves  are possible before fixing the WCS to the
   device, e.g. in a call to GLABAX.
   
   A VIEWPORT is any rectangular plotting area lying  entirely  within  the
   plotting  area  of  the  device.  The viewport defines the area in which
   data can be plotted, i.e., the boundary at which CLIPPING will occur  if
   enabled.   The  viewport is the area framed by GLABAX; the tick and axis
   labels will be plotted in the area just outside the viewport.  A  square
   viewport  need  not  have  the same resolution in both X and Y.  Devices
   with variable resolution, e.g. pen plotters, have a  default  resolution
   in  either  axis  which  can  be overridden when the plot is drawn.  The
   aspect ratio of the device is the  ratio  of  the  physical  size  of  a
   device  pixel  in  Y to that in X.  Most devices have an aspect ratio of
   unity, but it is common for the resolution to be different in X  and  Y.
   The  aspect  ratio  of the device is available via a GGET inquiry, as is
   the device resolution in either axis.
   
   A WINDOW is the range of world coordinates which GIO  will  map  to  the
   corresponding  viewport.   The  world  coordinates must be cartesian and
   either linear or logarithmic (base 10) in either  axis.   There  are  no
   restrictions  on the range of world coordinates other than those imposed
   by the single precision floating point hardware of  the  host  computer,
   provided that the WCS is not degenerate (zero range in either axis).
   
   Most  applications  will  use only a single WCS, hence the WCS number is
   not included explicitly in the argument lists of the GIO procedures.   A
   call  to  GSET is required to change to a different WCS.  Thereafter all
   graphics output and cursor input will refer to the  new  WCS.   Multiple
   WCS  are  useful  when  plotting  in  several  distinct (nonoverlapping)
   viewports on a device, or  when  overplotting  curves  within  the  same
   viewport but with different world coordinate windows.
   
   
   




                                     -4-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.2 GRAPHICS OUTPUT PROCEDURES
   
       The  GIO  output  procedures range from GPLOTV and GPLOTO, which can
   draw an entire plot with autoscaling and axis labelling in one call,  to
   the  polyline,  polymarker,  move,  draw, and text drawing primitives at
   the low end.
   
   
                  gplotv (v, npts, x1, x2, title)
                  gploto (gp, v, npts, x1, x2, title)
               gpagefile (gp, fname, prompt)
                   
              gp = gopen (device, mode, fd)
                  gclose (gp)
             gdeactivate (gp, flags)
             greactivate (gp, flags)
                 gcancel (gp)
                  gflush (gp)
                  gclear (gp)
                  gframe (gp)
                  greset (gp, flags)
                gmftitle (gp, metafile_title)
   
                   gscan (gp, text)
               gset[irs] (gp, param, value)
        val = gstat[irs] (gp, param[, outstr, maxch])
        val = gget[birs] (gp, devcap[, outstr, maxch])
               g[sg]view (gp, x1, x2, y1, y2)
               g[sg]wind (gp, x1, x2, y1, y2)
              g[ar]scale (gp, v, npts, axis)
                 ggscale (gp, x, y, dx, dy)
                  gctran (gp, x1, y1, x2, y2, wcs1, wcs2)
                 gcurpos (gp, x, y)
                 gescape (gp, fn, instruction, nwords)
   
                  glabax (gp, title, xlabel, ylabel)
                   gline (gp, x1, y1, x2, y2)
                  gpline (gp, x, y, npts)
                  gvline (gp, v, npts, x1, x2)
                   gmark (gp, x, y, marktype, xsize, ysize)
                  gpmark (gp, x, y, npts, marktype, xsize, ysize)
                  gvmark (gp, v, npts, x1, x2, marktype, xsize, ysize)
                  gumark (gp, x, y, npts, xcen, ycen, xsize, ysize, fill)
               g[ar]move (gp, x, y)
               g[ar]draw (gp, x, y)
                   gtext (gp, x, y, text, format)
                   gfill (gp, x, y, npts, style)
               g[pg]cell (gp, m, nx, ny, x1, y1, x2, y2)
   
                   gscur (gp, x, y)
            stat = ggcur (gp, x, y, key)
   
   
   All coordinates  are  given  in  world  coordinates  (user  coordinates)
   except the viewport coordinates and the marker sizes, which are given in


                                     -5-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   device coordinates.  Low level graphics i/o requires that  the  graphics
   device  first  be  opened  with  GOPEN  and  later  closed  with GCLOSE.
   Several graphics devices may be open simultaneously.
   
   When a graphics device is opened with GOPEN all internal parameters  are
   initialized  to  their  default  values,  unless the device is opened in
   APPEND mode.  The default values of these  internal  parameters  may  be
   changed  via  explicit  GSET,  GSWIND,  GSCALE,  or  GSCAN  calls.  Most
   powerful is GSCAN, which interprets graphics commands passed  either  as
   an explicit string or in a text file.
   
   Much  of  the  flexibility  of GIO derives from its parameter defaulting
   mechanism.  The interface may be expanded  indefinitely  by  adding  new
   internal  parameters accessed via GSET calls, without changing the basic
   interface.
   
   
   
   3.3 GRAPHICS INPUT PROCEDURES
   
       The most commonly used type of graphics input  is  cursor  readback.
   Two  forms  of  cursor  input  are  supported: cursor input via the CLIO
   procedure CLGCUR, and cursor input via the GIO  procedure  GGCUR.   CLIO
   based  cursor input should be used whenever possible, i.e., when writing
   to STDGRAPH or STDIMAGE.  The advantage of cursor input via  the  CL  is
   that  input  may come from a list file or the terminal as well as from a
   physical cursor read, allowing programs to be used either  interactively
   or  in  batch  mode.   Furthermore,  WCS selection and conversion of NDC
   cursor  coordinates  to  WCS  and  cursor  mode  interaction  are   only 
   available  with  CLGCUR.   Programs  which  do  not produce any graphics
   output may read the cursor via CLIO without using any part  of  the  GIO
   interface.   The  lower level GIO cursor read procedure always reads the
   physical device cursor in NDC coordinates and is  device  dependent  (it
   is what is called by CLGCUR).
   
   Cursors  are  implemented  as  abstract datatypes within the CL.  A user
   task accesses a cursor by reading the value of a CL  parameter  of  type
   GCUR (stdgraph cursor) or IMCUR (stdimage cursor).  Multiple cursors may
   be  implemented  using  multiple  cursor  type  parameters.   A   cursor 
   parameter  is assumed to have a LIST of values; EOF is returned when the
   end of the list is reached.  Reading  the  cursor  automatically  causes
   any graphics output to be flushed.
   
           stat = clgcur (param, wx, wy, wcs, key, strval, maxch)
   
   The  CLIO  function  CLGCUR  reads  the next cursor value from the named
   cursor parameter, returning as output arguments the cursor  position  in
   world  coordinates, the index of the referenced WCS, the keystroke value
   (character typed) of the cursor event, and a string  value  if  the  key
   was  ':',  the  cursor  mode set option escape character.  A cursor read
   sequence begins with a prompt, i.e., the  cursor  lights  up  or  starts
   blinking.   The  user  is then free to move the cursor about; the cursor
   position is not read until a key is typed on the user  terminal.   Using
   a  keystroke  on  the  user  terminal  to  terminate  both  STDGRAPH and
   STDIMAGE cursor reads provides a rich  and  device  independent  set  of


                                     -6-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   keystroke  values  for  identifying  the action to be performed (imaging
   devices are typically very limited in this area).
   
   GIO always returns the cursor position in world coordinates, along  with
   the  index  of  the  WCS  selected.  Typically there will be exactly one
   world coordinate system (excluding WCS 0)  and  the  WCS  value  may  be
   ignored.   If no world coordinate systems are defined for the device the
   cursor position will be returned in NDC coordinates with WCS=0.
   
   If multiple world coordinate systems are defined GIO will select the WCS
   closest  to the position of the cursor, i.e., the cursor may lie outside
   the viewport and GIO will still return WCS coordinates.  If  the  cursor
   lies  within  two  or more overlapping viewports GIO will select the WCS
   with the highest number.  The cursor read protocol will allow  the  user
   to  force  the  selection  of a particular viewport by first placing the
   cursor on a nonoverlapping portion of the viewport and typing a  special
   code,  e.g.,  W  (see next section), and then continuing with the normal
   cursor read.  If the application wishes to override  the  automatic  WCS
   selection  it  may  do  so  by  calling  GCTRAN  to transform the cursor
   coordinates returned by CLGCUR to a different world coordinate system.
   
   
   
   3.3.1 CURSOR MODE
   
       In cursor mode, i.e.,  after  a  call  to  CLGCUR  or  after  typing
   "=gcur",  a  number  of  special  keystrokes  shall  be  recognized  for 
   interactive display  control.   All  graphics  output  to  stdgraph  and
   stdimage  is  routed  through  the CL on the way to the graphics kernel.
   The CL  will  optionally  spool  in  an  internal  buffer  all  graphics
   instructions  output  to an interactive device.  This internal buffer is
   emptied whenever the device screen is cleared.  In cursor mode,  special
   keystrokes  may  be  used  to  redraw  all or any portion of the spooled
   graphics, e.g., one may zoom in on a portion of the plot and  then  roam
   about  on  the  plot  at high magnification.  Since the spooled graphics
   vectors typically contain more information  than  can  be  displayed  at
   normal  magnification,  zooming in on a feature may bring out additional
   detail  (the  maximum  resolution  is  32768  points  in  either  axis). 
   Increasing  the  magnification will increase the precision of the cursor
   by the same factor.
   
   Cursor mode is implemented by performing coordinate  transformation  and
   clipping  on  each  GKI  instruction  in  the  frame buffer, passing the
   transformed and clipped instructions on to  the  graphics  kernel.   The
   cursor  mode operations perform a simple geometric transformation on the
   spooled graphics frame, mapping a  rectangular  window  of  the  spooled
   frame  onto  the  device  screen.   The  graphics  frame  itself  is not
   modified, hence zoom out or reset and redraw will restore  the  original
   display.
   
   If  the  graphics frame is a typical vector plot with drawn and labelled
   axes, magnifying a portion of the plot may cause the axes  to  be  lost.
   If this is not what is desired a keystroke is provided to draw and label
   the axes of the displayed window.  The axes will be overplotted  on  the
   current  display  and  will not be saved in the frame buffer, hence they


                                     -7-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   will be lost when the frame is redrawn.  In cursor mode the viewport  is
   the  full  display area of the output device, hence the tick mark labels
   of the drawn axes will be drawn inside the viewport.  This form of  axes
   labelling is used because it is simple and because it is appropriate for
   both vector graphics and image display output devices (and  cursor  mode
   must serve both).
   
   
           A                       draw and label the axes of current viewport
           B                       backup over last instruction in frame buffer
           C                       print the cursor position as it moves
           D                       draw a line by marking the endpoints
           E                       expand plot by setting window corners
           F                       set fast cursor (for HJKL)
           H                       step cursor left
           J                       step cursor down
           K                       step cursor up
           L                       step cursor right
           M                       move point under cursor to center of screen
           P                       zoom out (restore previous expansion)
           R                       redraw the screen
           T                       draw a text string
           U                       undo last frame buffer edit
           V                       set slow cursor (for HJKL)
           W                       select WCS at current position of cursor
           X                       zoom in, X only
           Y                       zoom in, Y only
           Z                       zoom in, both X and Y
           <                       set lower limit of plot to the cursor y value
           >                       set upper limit of plot to the cursor y value
           \                       escape next character
           :                       set cursor mode options
           :!                      send a command to the host system
           =                       shorthand for :.snap (make graphics hardcopy)
           0                       reset and redraw
          1-9                      roam
                       Figure 2. Cursor Mode Keystrokes
   
   
   By  default  the  cursor  mode  keystrokes  are  all upper case letters,
   reserving lower case for  applications  programs.   The  terminal  shift
   lock  key  may  be used to simplify typing in lengthy interactive cursor
   mode sessions.  The cursor motions are decoupled from  roam  since  zoom
   and  roam  are  often  used merely to increase the precision of a cursor
   read.  Special keystrokes are provided for stepwise  cursor  motions  to
   increase  the speed of cursor setting on terminals that do not have fast
   cursor  motions  (e.g.,  the  retro-graphics   enhanced   VT100).    The 
   recognized keystrokes are shown in Figure 2.
   
   If  the  character : is typed while in cursor mode the alpha cursor will
   appear at the bottom of the  screen,  allowing  a  command  line  to  be
   entered.    Commands   which   begin  with  a  period,  e.g.,  ":."  are 
   interpreted by the graphics system; any  other  command  will  terminate
   the  cursor  read, returning the character ':' as the key value, and the
   command string as the string value of the  cursor  read.   The  commands


                                     -8-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   recognized by the graphics system are summarized in figure 3.
   
   
           :.axes[+-]              draw axes of viewport whenever screen is redr
awn
           :.case[+-]              enable case sensitivity for keystrokes
           :.clear                 clear alpha memory (e.g, this text)
           :.cursor n              select cursor (0=normal,1=crosshair,2=lightpe
n)
           :.gflush                flush plotter output
           :.help                  print help text for cursor mode
           :.init                  initialize the graphics system
           :.markcur[+-]           mark cursor position after each cursor read
           :.off [keys]            disable selected cursor mode keys
           :.on [keys]             enable selected cursor mode keys
           :.page[+-]              enable screen clear before printing help text
           :.read file             fill frame buffer from a file
           :.show                  print cursor mode and graphics kernel status
           :.snap [device]         make hardcopy of graphics display
           :.txqual qual           set character generator quality (normal,l,m,h
)
           :.txset format          set text drawing parameters (size,up,hj,vj,et
c)
           :.xres=value            set X resolution (stdgraph only)
           :.yres=value            set Y resolution (stdgraph only)
           :.viewport x1 x2 y1 y2  set workstation viewport in world coordinates
           :.write[!][+] file      save frame buffer in a spool file
           :.zero                  reset viewport and redraw frame
   
   
                        Figure 3. Cursor Mode Commands
   
   
   Minimum match abbreviations are permitted for cursor mode command names.
   Multiple commands may be given on one  line,  delimited  by  semicolons.
   If  the  CL  environment  variable CMINIT is defined when cursor mode is
   first entered, the string value will be interpreted  as  a  cursor  mode
   command  and  used  for  initialization.   For  example,  to disable the
   numeric keys and set the graphics resolution to 200 points in X and  100
   points  in  Y,  one  could  add  the  following SET declaration to their
   "login.cl" file:
   
           set cminit = "xres=200; yres=150; off 0-9"
   
   The numeric keypad of the terminal (if it has one) is used to roam about
   when  the  zoom  factor  is  greater  than one.  If the magnification is
   normal the numeric keys are not recognized as special keystrokes,  i.e.,
   typing  a  numeric  key  will  exit cursor mode, returning the character
   typed to the applications program.  In roam mode a numeric key  must  be
   escaped  to  exit  cursor  mode.   The  directional  significance of the
   numeric keys in roam mode is obvious if the terminal has a  keypad,  and
   is illustrated below.
   
   







                                     -9-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           7   8   9       135 090 045
   
           4   5   6       180 000 000
   
           1   2   3       225 -90 -45
   
   
   There  is  a  fixed  upper  limit  on  the size of the cursor mode frame
   buffer.  If the frame data overflows the  frame  buffer  while  plotting
   the  plot  will  still  come  out correctly, but only the final plotting
   instructions will be retained in the buffer.  Redisplay of the frame  in
   cursor  mode  will thus result in only a portion of the full frame being
   drawn.  If this is a problem the user can increase the  upper  limit  on
   the  size  of  the  frame buffer by setting the value of the environment
   variable CMBUFLEN, e.g.,
   
           gflush; set cmbuflen = 512000
   
   would initialize the graphics system (freeing the old frame buffer)  and
   set  the  upper  limit  on the size of the frame buffer to 512K words or
   1Mb.
   
   
   
   3.4 EXAMPLE
   
       At this point a brief example may help to illustrate the use of  the
   GIO  procedures.  The following procedure will plot a data vector (pixel
   array)  and  then  repeatedly  read  the  cursor,  drawing  a  mark   at 
   successive  positions  of  the  cursor.  The procedure exits if the user
   types either the character  'q'  or  EOF,  e.g.,  <ctrl/z>  or  carriage
   return.
   
   























                                    -10-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           include <gset.h>
   
           # MARKPLOT -- Plot a data array and then enter a loop, drawing
           # circles at successive cursor positions.
   
           procedure markplot (data, npts, x1, x2)
   
           real    data[npts]              # data vector to be plotted
           int     npts                    # length of array
           real    x1, x2                  # world X-coords of vector
   
           pointer gp
           int     wcs, key
           char    str[32]
           real    wx, wy
           pointer gopen()
           int     clgcur()
   
           begin
                   gp = gopen ("stdgraph", NEW_FILE, STDGRAPH)
   
                   call gploto (gp, data, npts, x1, x2, "data")
   
                   while (clgcur ("points", wx, wy, wcs, key, str, 32) != EOF)
                       if (key == 'q')
                           break
                       else
                           call gmark (gp, wx, wy, GM_CIRCLE, 1., 1.)
   
                   call gclose (gp)
           end
   
   
   
   3.5 GRAPHICS OUTPUT DEVICES
   
       While  the  graphics  output  device  may be specified explicitly by
   name, more often graphics output devices will be  specified  by  one  of
   the  logical  device  names  shown  below.  Examples of the installation
   dependent device name associated with each logical name are also shown.
   
   
           stdgraph        = "gterm"
           stdimage        = "deanza"
           stdplot         = "qms"
           stdvdm          = "uparm$vdm"
   
   
   Interaction (via the CL) is supported only for  STDGRAPH  and  STDIMAGE.
   The  standard batch plotter device is STDPLOT, and the standard metafile
   (for spooling graphics output) is STDVDM.
   
   The user should not normally set the value  of  STDGRAPH  directly  with
   SET,  rather  they  should  set  the terminal type with STTY and let the
   latter specify the value of STDGRAPH.  If the terminal specified is  not


                                    -11-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   a  graphics  terminal  (no ":gd" capability in the termcap entry for the
   device) the value of STDGRAPH will be set to "none", otherwise  STDGRAPH
   will  be  set  to the name of the stdgraph device entry for the graphics
   terminal.
   
   The device name associated with a logical graphics  output  device  must
   have  an  associated  entry  in  the  GRAPHCAP file, a text file used to
   describe the characteristics of each device.  New graphcap  entries  may
   easily  be  added  by the user to interface to special graphics devices.
   System privledge is not required to modify graphcap, since the  name  of
   the  graphcap  file  is taken from a CL environment variable of the same
   name (which can be redefined by the  user  to  point  to  a  file  in  a
   private  directory).   The  graphcap  entries for the most commonly used
   devices at a given site may be precompiled  by  the  system  manager  to
   eliminate the overhead of searching the graphcap file at GOPEN time.
   
   The  graphcap  parameters  (device  CAPABILITIES) are too involved to be
   presented here and will be described in a later  section.   Examples  of
   device  capabilities  are the device resolution, whether a frame advance
   is required before or after a plot, indication  of  device  capabilities
   such  as  the  ability  to generate text, and the name of the executable
   graphics kernel  file  associated  with  the  device.   Many  additional
   parameters  are  defined  for  interactive devices.  The graphcap device
   capabilities may be inspected  with  the  GGET[BIRS]  procedures,  which
   resolve  into  calls  to the TTY interface, used to access both graphcap
   and termcap files.
   
   The sequence of actions taken by GIO to access the graphcap entry for  a
   device is summarized below.
   
   
           if (standard graphics output device)
               get device name from environment
   
           if (device name is actually a filename) {
               load graphics device descriptor using the first device entry
                   from the named graphcap format file
           } else {
               get filename of graphcap file from environment
               load graphics device descriptor by searching the graphcap file
                   for the named device
           }
   
   
   
   3.6 GRAPHICS INPUT DEVICES
   
       The  technique  used  to  associate  an input source with a graphics
   cursor is similar to that used for output  devices.   A  CL  environment
   variable  is  associated  with  each cursor type.  The names and default
   values of the environment variables are shown below.
   
   




                                    -12-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           stdgcur         = "stdgraph"
           stdimcur        = "stdimage"
   
   
   The default input source for a cursor  is  the  graphics  output  device
   associated  with  the  graphics  output stream.  If the cursor device is
   "stdgraph" or "stdimage" the graphics  kernel  is  called  to  read  the
   physical  device  cursor for STDGRAPH or STDIMAGE.  If the cursor device
   is "text" the cursor value  is  a  line  of  text  read  from  the  user
   terminal.   In  this  mode  the  user  enters at least two of the fields
   defining a cursor value.  Missing fields are  assigned  the  value  zero
   (the  user  presumably will know that the program does not use the extra
   fields).
   
   
           cl> set stdgcur = "text"
           cl> = gcur
           gcur: 345.33 23.22 1 c
           345.33 23.22 1 c
           cl>
   
   
   An example of a cursor read request entered interactively by  the  user,
   taking  input  from  the terminal and sending output to the terminal, is
   shown above (the CL typed the "gcur: " query and the  user  entered  the
   remainder  of  that  line).  If the cursor device were "stdgraph" a real
   cursor read would occur and the equivalent interaction might  appear  as
   shown  below.   The  cursor  position  is returned in world coordinates,
   where the world coordinate system was defined by the last plot output to
   the  device.  For an imaging device the world coordinates will typically
   be the pixel coordinates of the image section being displayed.
   
   
           cl> = gcur
           345.33 23.22 1 c
           cl>
   
   
   Redirecting cursor input to the terminal is useful when working  from  a
   nongraphics  workstation  and  when  debugging  programs.   ASCII cursor
   queries are the  only  type  supported  when  running  an  IRAF  program
   outside  the  CL.   Cursor  input  may also be taken from a list file by
   assigning a filename to a cursor parameter, i.e., by  assigning  a  list
   file to a list structured parameter and overriding query mode:
   
   
           cl> gcur = filename
           cl> = gcur
           345.33 23.22 1 c
           cl>
   
   
   This last mechanism is a standard technique used with CL list structured
   parameters and will not be discussed further here.
   


                                    -13-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.7 MIXED TERMINAL AND GRAPHICS I/O
   
       Interactive graphics programs are  normally  (but  not  necessarily)
   executed  on a graphics terminal or workstation supporting both ordinary
   terminal i/o and vector graphics.  IRAF is  designed  to  use  a  single
   terminal  for  both  text  and  graphics;  text and graphics on separate
   devices is also supported but is not the norm.  By text  we  refer  here
   to  ordinary  line  or  screen  oriented terminal i/o (e.g., for HELP or
   EPARAM), not the use of text in the graphics plane to annotate plots.
   
   
   
   3.7.1 TEXT AND GRAPHICS MODE
   
       Most modern graphics terminals provide separate  memory  planes  for
   text  and  graphics.   Depending  upon  the  device, these planes may be
   displayed  simultaneously,  displayed  alternately,  or  only  a  single 
   memory  plane  may be available for both terminal modes, in which case a
   mode switch is destructive.  The graphics device  model  implemented  by
   GIO  and  the  STDGRAPH  kernel  is  flexible enough to deal with all or
   nearly all such devices.
   
   The  normal  mode  for  the  terminal  or  workstation  is  text   mode. 
   Activating   the   workstation   causes   a  switch  to  graphics  mode; 
   deactivating  the  workstation  restores  the  terminal  to  text  mode. 
   Activation  is  implied  whenever  a device is opened with GOPEN, unless
   the AW_DEFER mode bit is set to defer  the  activate  workstation  until
   graphics  i/o  is  actually done to the device.  Closing the workstation
   automatically  deactivates  the   workstation.    The   GIO   procedures 
   GREACTIVATE  and  GDEACTIVATE  are  provided  to simplify mode switching
   while a device is open on a graphics stream.
   
   Occasionally it is necessary to print out a  large  amount  of  text  in
   response  to  a  user command entered in a cursor loop while in graphics
   mode.  If the text is in a file this is  done  most  easily  by  calling
   GPAGEFILE  to  page  the file in text mode, restoring graphics mode when
   the operation is completed.  If the  application  generates  the  output
   text  dynamically  then  the  workstation must be explicitly deactivated
   and later reactivated before resuming graphics i/o, e.g.,
   
           while (clgcur (gp, ...) != EOF) {
               switch (key) {
               case XXX:
                   call gdeactivate (gp, AW_CLEAR)
                       <write the text to STDOUT>
                   call greactivate (gp, AW_PAUSE)
               case YYY:
                   ...
               }
           }
   
   The sequence shown will switch to text mode, clear  the  screen,  output
   the  text,  and  pause  for  the  user to read the text before restoring
   graphics mode and initiating another cursor read.
   


                                    -14-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.7.2 STATUS LINE I/O
   
       The  deactivate/reactivate  workstation  technique   is   fine   for 
   outputting  large  amounts  of  text,  but  is not well suited for small
   amounts of  text,  e.g.,  single  line  commands  to  interactively  set
   internal  parameters, output of single lines of text to prompt the user,
   print the value of a calculation or  some  variable,  and  so  on.   The
   so-called  "status line" interface is provided for this purpose.  Status
   line i/o makes it possible to interact directly with  the  user  without
   interfering  with  the  contents  of  the  graphics  frame,  and without
   leaving graphics mode.
   
   What the status line actually is is determined  by  the  graphcap  entry
   for  the  device  and  the  characteristics or limitations of the actual
   device.  On most devices, the status  line  is  a  single  line  at  the
   bottom  of  the  screen.   This  only  works, however, if the device can
   dynamically erase the status line; if this is not  possible  the  status
   "line"  may  actually be the entire screen, with successive output lines
   being drawn on top of the graph.
   
   To output text to the status line while  in  graphics  mode  one  merely
   writes  to  STDOUT  or  STDERR  in  the  usual  way,  e.g., in a call to
   PRINTF.  When newline is seen a flag is  set  which  causes  the  status
   line  to  be cleared when the next output character is received.  Output
   lines may  be  built  up  in  successive  calls  to  output  procedures,
   outputting  a  single newline to terminate the line and start a new one.
   After a newline delimited line of text has  been  output,  output  of  a
   single newline (blank line) will clear the status line.
   
   It  is  also  possible  to  read  from  the  status  line.  This is most
   commonly done after writing a prompt string to  the  status  line.   The
   prompt  should be terminated with a colon (e.g., "enter value: ") rather
   than a newline, to signal to the user that input  is  expected,  and  to
   avoid  having  the  subsequent status line read clear the prompt string.
   In many cases such explicit prompting and decoding of the return  string
   can  be avoided by using the standard CLIO parameter prompting mechanism
   for interactive input.  CL  parameter  prompts  are  also  permitted  in
   graphics  mode,  and  will  interact with the user on the status line in
   the expected way, without interfering with the  graphics  state  of  the
   device.
   
   When  mixing  status  line  i/o  and graphics i/o one must be careful to
   flush any buffered graphics or textual output  before  switching  modes.
   In  many  cases the system will do this for you automatically, but there
   are  exceptions  where  explicitly  flushing  of  buffered   output   is 
   necessary  (e.g.,  STDOUT  and  STDERR  are low level facilities with no
   knowledge  of  GIO,  and  output  to  one  of  these  streams  will  not 
   automatically cause any graphics output to be flushed).
   
   
   
   3.8 USER INTERFACE CONVENTIONS
   
       While  different  interactive (cursor driven) graphics programs will
   differ in many ways, there are certain operations which  are  common  to


                                    -15-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   all  such  programs.  In order to present a more consistent interface to
   the user, conventions have been defined for these common operations.
   
   
   
   3.8.1 ON LINE HELP
   
       All interactive graphics programs should  respond  to  the  key  '?'
   with  a  description  of the keystrokes and colon commands recognized by
   the program (or submenu, in the case of a  menu  structured  interface).
   This  is  normally  done  by calling GPAGEFILE to interactively page the
   ".key" keystrokes help file for the program.  The  keystroke  files  for
   system   programs  are  stored  in  the  directory  lib$scr;  non-system 
   programs keep their keys files either in the package directory, or in  a
   global package library.
   
   
   
   3.8.2 CURSOR AND DEVICE NAMES
   
       In general, applications programs should not read directly from GCUR
   or IMCUR (the  global  cursor  parameters),  nor  should  the  open  the
   "stdgraph",  "stdimage",  or "stdplot" device directly by these explicit
   string values.  This works, but is inflexible.  To make it easy for  the
   user  to  run  an  otherwise  interactive  program in batch mode, taking
   input from a cursor list file, the task should  include  a  cursor  type
   parameter  in its parameter set.  Likewise, to make it easy for the user
   to temporarily redirect the output of the  program  to  a  device  other
   than  the  current  stdgraph,  stdplot,  etc.,  device,  the device name
   should be parameterized as a string type CL parameter.
   
   For example, if task PLOTIT  has  cursor  and  device  parameters  named
   "cursor" and "device", the command
   
           cl> plotit cursor=listfile device=qms
   
   would  run  the  task taking cursor input from the text file "listfile",
   with stdgraph graphics output directed to the plotter device "qms".
   
   
   
   3.8.3 EXITING AN INTERACTIVE CURSOR LOOP
   
       The following standards have been defined for dealing with  EOF/quit
   in interactive cursor loops.
   
       EOF 
           End  of  file is indicated for a cursor list either by an actual
           end of file in the case of a true cursor list, or by typing  the
           EOF  character  (e.g.,  <ctrl/z>,  <ctrl/d>,  or  the  interrupt 
           character) in an interactive cursor read.   EOF  on  the  cursor
           list  should be taken seriously by the applications program, and
           not treated  as  just  another  key,  hence  it  should  not  be
           something  that the user is expected to type routinely to exit a
           cursor loop.  If a program gets EOF back as the value of  CLGCUR


                                    -16-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           it  should  exit  immediately,  without any verification queries
           etc, since it may well have been run in batch  mode  with  input
           redirected to a cursor list file.
       
       q   The  standard  interactive  cursor  loop  exit character is 'q'.
           All  interactive  graphics  programs   should   recognize   this 
           character and take some action to exit the cursor loop, e.g.:
           
                   while (clgcur (...) != EOF)
                       switch (key) {
                       case 'q':
                           break
                       case ...
           
           The  'q'  character  is  intended  to be handled directly by the
           application program, rather than mapped into EOF by  the  system
           (like  Q  was,  and  CR  and  the gt_gcur 'q' before that in old
           versions of IRAF), to distinguish this case from a hard-EOF  and
           to  provide  maximum  flexibility  in  how  the program treats a
           request from the user to exit.  If the user  would  suffer  from
           an  accidental  program  exit  then the 'q' key action should do
           something before exiting, e.g., ask that the user  first  update
           the  database, ask that CR be hit to verify the quit, and so on.
           In general, if it would take the user  more  than  a  minute  to
           recover  after  an  accidental program exit, one should consider
           coding some sort of verification action to  be  executed  before
           exiting  when  'q'  is  typed  (but  not when EOF is seen on the
           list).
   
   The GIO procedure GQVERIFY is provided for  programming  convenience  in
   cases  where only simple verification is desired.  Note that lightweight
   tasks or submenus which can easily be reentered should not  bother  even
   with this, but should simply exit.  For example:
   
           case 'q':
               if (gqverify() == YES)
                   break
   
   As  a  more  complex  example,  suppose  the  program is used to edit or
   create a database which could be lost or damaged in an accidental  exit,
   if   not  updated  first.   We  do  not  want  to  update  the  database 
   automatically because this would overwrite the former  contents  of  the
   database.  The program might be set up as follows.
   
           'q'             program prints error message on status line, e.g.,
                             "No write since last change (:quit! overrides)"
           :w[rite]        updates the database; q will execute silently
           :q[uit]!        force a quit w/o an update; discard changes
   
   
   
   3.9 DETAILED PROCEDURE SPECIFICATIONS
   
       The  graphics  output procedures provided by GIO fall into four main
   groups.  First are the high level "plot at a time" procedures,  used  to


                                    -17-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   plot  entire  data  vectors.  Second are the control procedures, used to
   open and close a device, to flush output and clear the  screen,  and  to
   cancel  output  in  the event of an interrupt.  Third are the procedures
   used to set and stat (inquire) the  GIO  internal  parameters,  e.g.  to
   define  a  WCS,  change  pens, select axis labelling options, or inquire
   the device resolution.  Fourth and last are the output procedures,  used
   to  draw and label the axes of a viewport, set the cursor, draw lines or
   marks, plot text, or fill areas.
   
   
   
   3.9.1 HIGH LEVEL PROCEDURES
   
       
       gplotv (v, npts, x1, x2, title)
           
           real    v[npts]         # data vector
           int     npts            # number of data points
           real    x1, x2          # WC assigned v[1] and v[npts]
           char    title[ARB]      # plot title
           
           Open GIO, clear the screen, autoscale and plot the data  vector,
           then  close  GIO.   A  default  viewport  is used.  The axes are
           drawn, tick marks are selected, marked, and  labelled,  and  the
           plot  title  is  printed.   The data is plotted using solid line
           segments.   The  X  values  of  the  data  points   are   evenly 
           distributed from X1 to X2.
       
       
       gploto (gp, v, npts, x1, x2, title)
           
           pointer gp              # graphics descriptor
           real    v[npts]         # data vector
           int     npts            # number of data points
           real    x1, x2          # WC assigned v[1] and v[npts]
           char    title[ARB]      # plot title
           
           A  more  flexible  version  of GPLOTV.  The graphics device must
           already have been opened with an explicit call  to  GOPEN.   The
           explicit  open  call  makes it possible to append to an existing
           plot or to change plotting options with  calls  to  GSET  before
           calling  GPLOTO  to  autoscale, draw the axes, and plot the data
           vector.  Annotation of the plot  via  calls  to  the  low  level
           output  primitives  is possible before a final call to GCLOSE to
           close the device and free the graphics descriptor.
       
       
       gpagefile (gp, fname, prompt)
           
           pointer gp              # graphics descriptor
           char    fname[ARB]      # file to be paged
           char    prompt[ARB]     # end of page prompt string
           
           Interactively page through a file on the terminal in text  mode,
           e.g.,  to display help text in response to the '?' standard help


                                    -18-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           query key.   The  workstation  is  deactivated,  the  screen  is
           cleared  and the file is paged, with the usual file pager prompt
           being displayed at the bottom of each page of  text.   When  the
           pager  is exited the workstation is reactivated if it was active
           when the pager was called.  If the prompt  string  is  null  the
           file name is used.
   
   
   
   3.9.2 CONTROL PROCEDURES
   
       
       gopen (device, mode, fd)
           
           char    device[ARB]     # name of device to be opened
           int     mode            # access mode
           int     fd              # graphics stream to be written
           
           The  named  graphics  device  is  opened  for  graphics  i/o.  A
           pointer to the GIO graphics descriptor assigned  to  the  device
           is  returned  as the function value.  The device name may be the
           name of one of the  standard  logical  graphics  devices,  i.e.,
           STDGRAPH,  STDIMAGE, STDPLOT, or STDVDM, or the actual name of a
           physical device.
           
           The only meaningful device access modes at present are  NEW_FILE
           and  APPEND.   In  NEW_FILE  mode all WCS are initialized to NDC
           coordinates.  Opening  the  stdgraph  device  in  NEW_FILE  mode
           causes  a  screen  clear  on the next call to GFLUSH.  In APPEND
           mode the WCS are restored  to  the  values  they  had  when  the
           device  was last accessed.  The GIO internal state variables are
           initialized to their default values at GOPEN time regardless  of
           the access mode for the device.
           
           Opening  the  stdgraph  device  causes  an  implicit  reactivate 
           workstation unless the AW_DEFER flag (<gset.h>) is  set  in  the
           access mode, e.g.,
           
                   gp = gopen (device, NEW_FILE+AW_DEFER, fd)
           
           Defer  mode  allows  the  graphics descriptor to be opened once,
           e.g.,  during  task  startup,  before  any  graphics  output  is 
           required.   This  is  sometimes  useful  in  applications  which 
           switch back and forth between text and graphics mode  often,  by
           bracketing  each  graphics sequence with calls to GREACTIVATE to
           enter graphics mode, and GDEACTIVATE to  return  to  text  mode.
           Defer mode may be combined with any normal access mode code.
           
           Graphics  output  will be written to the stream FD, which may be
           one of the standard streams STDGRAPH, STDIMAGE, or  STDPLOT,  or
           to  a  binary  file opened explicitly by the user before calling
           GOPEN.
       




                                    -19-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gclose (gp)
           
           The graphics device associated with graphics  descriptor  GP  is
           closed,  freeing  all  resources  allocated  to the device.  Any
           buffered  graphics  output  is  automatically   flushed   before 
           closing the device.
       
       
       gdeactivate (gp, flags)
           
           pointer gp              # graphics descriptor
           int     flags           # AW_CLEAR, AW_PAUSE (see <gset.h>)
           
           The  graphics  workstation is deactivated, i.e., restored to the
           normal terminal (text drawing) mode, the state the terminal  was
           in  prior  to  GOPEN,  and  to which it will be restored after a
           GCLOSE.  This function  is  intended  for  interactive  graphics
           applications  and  may  be  may  be  ignored  by  some  graphics 
           kernels.  If the AW_PAUSE flag bit  is  set  the  user  will  be
           asked  to  type  a  key  before the terminal is restored to text
           mode.  If the AW_CLEAR flag  bit  is  set  the  terminal  (text)
           screen will be cleared after the workstation is deactivated.
           
       
       
       greactivate (gp, flags)
           
           pointer gp              # graphics descriptor
           int     flags           # AW_CLEAR, AW_PAUSE (see <gset.h>)
           
           The  graphics  workstation  is  reactivated,  i.e.,  restored to
           graphics mode from the  normal  terminal  (text  drawing)  mode.
           This  function is intended for interactive graphics applications
           and may be may be ignored by  some  graphics  kernels.   If  the
           AW_PAUSE  flag  bit  is set the user will be asked to type a key
           before the terminal  is  restored  to  graphics  mode.   If  the
           AW_CLEAR flag bit is set the graphics frame will be cleared.
       
       
       gcancel (gp)
           
           Any  buffered  graphics  output  is  discarded  and  any  output 
           operation currently in progress is  aborted.   Used  to  recover
           from an interrupt.
       
       
       gflush (gp)
           
           Any buffered graphics output is flushed to the output device.
       
       
       gclear (gp)
           
           If  the  output  device is a CRT the screen is erased (including
           all viewports).  If the output device is a  plotter  a  formfeed


                                    -20-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           is  issued, advancing to the next page of output (whether or not
           any graphics output has occurred).  All WCS are  initialized  to
           NDC  coordinates  and  the internal state of GIO is initialized,
           i.e., the state of each drawing instruction attribute packet  is
           set  to  UNSET to force retransmission to the graphics kernel as
           i/o occurs, and the current settings of the GSET options,  e.g.,
           line  style and width, GLABAX options, etc., are all initialized
           to their default (GOPEN) values.
       
       
       gframe (gp)
           
           Issue a screen clear or frame advance.  This call is  equivalent
           to  GCLEAR  except  that  the  internal  state  of  GIO  is  not 
           initialized.  An application  might  want  to  call  GFRAME  and
           GRESET   directly   rather   than  using  GCLEAR,  if  the  full 
           initialization implied by GCLEAR is not what is desired.
       
       
       greset (gp, flags)
           
           pointer gp              # graphics descriptor
           int     flags           # bitflags noting what to reset (0 is a no-op
)
           
           The GRESET may be used to reset all or  parts  of  the  internal
           state  of  GIO,  without  actually doing any i/o to the graphics
           device.  The FLAGS argument is used to specify  what  is  to  be
           reset.  The bitflags (defined in <gset.h>) are enumerated below.
           
                   GR_RESETALL             reset everything
                   GR_RESETGIO             reset only GIO drawing parameters
                   GR_RESETWCS             reset the WCS to wcs=1, all NDC
                   GR_RESETGLABAX          reset the GLABAX parameters
           
           A   GCLEAR   is   equivalent   to   a   GFRAME   followed  by  a 
           greset(gp,GR_RESETALL).
       
       
       gmftitle (gp, mftitle)
           
           pointer gp              # graphics descriptor
           char    mftitle[ARB]    # comment (metafile title string)
           
           Place a comment describing the graphics being generated  in  the
           output  stream.  Useful primarily when the output is expected to
           be saved in a metafile.  No graphics is generated.
   
   
   
   3.9.3 SET AND STAT PROCEDURES
   






                                    -21-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gscan (gp, text)  [NOT YET IMPLEMENTED]
           
           pointer gp              # graphics descriptor
           char    text[ARB]       # graphics commands
           
           The string TEXT, consisting of an arbitrary length  sequence  of
           printable  ASCII  graphics  commands  delimited by semicolons or
           newlines,  is  interpreted  and  executed  by  GIO.   Each   GIO 
           procedure  has a corresponding command of the same syntax, minus
           the parenthesis, commas, and the argument GP.  The syntax  of  a
           GSET  command  is  "param=value".  File inclusion is provided by
           the operator "@" followed by the filename  of  the  file  to  be
           included.   The  include operator may appear anywhere a token is
           expected and includes may be nested up to  some  maximum  depth.
           The   sequence   "@STDIN"  is  especially  useful  for  entering 
           commands or data interactively.
       
       
       gset[irs] (gp, param, value)
           
           pointer gp              # graphics descriptor
           int     param           # parameter to be set
           [irs]   value           # new value for parameter
           
           Set the value of the indicated parameter.  A separate  procedure
           is  used  for integer, real, and string valued parameters, i.e.,
           gseti, gsetr, gsets.  GIO  parameters  may  be  either  internal
           state  variables (e.g. the number of ticks on an axis) or device
           parameters (e.g. the number of  the  pen  to  be  used  to  draw
           lines).   The  GIO  parameters are defined in the global include
           file <GSET.H>.
       
       
       gstati (gp, param)
       gstatr (gp, param)
       gstats (gp, param, outstr, maxch)
       
           pointer gp              # graphics descriptor
           int     param           # parameter to be set
           char    outstr[maxch]   # output string
           
           Inquire the value of the indicated GIO internal parameter.   The
           integer   and  real  functions  GSTATI  and  GSTATR  return  the 
           parameter value as the  function  value,  whereas  GSTATS  is  a
           procedure  returning  the  string  value  of  a  parameter as an
           output argument.  The GIO parameters are defined in  the  global
           include file <GSET.H>.
       









                                    -22-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       ggetb (gp, cap)
       ggeti (gp, cap)
       ggetr (gp, cap)
       ggets (gp, cap, outstr, maxch)
       
           pointer gp              # graphics descriptor
           char    cap[2]          # device capability
           char    outstr[maxch]   # output string
           
           Inquire  the  value of the indicated graphics device capability.
           The device capability CAP is  the  two  character  name  of  the
           capability  as  it appears in the GRAPHCAP file.  Aside from the
           device capabilities required by GIO, GIO  itself  knows  nothing
           about  the  graphcap  device capabilities.  New capabilities may
           be added without modifying GIO.  The GGET  procedures  call  the
           corresponding  procedures in the TTY interface.  If more control
           over device capabilities is required than that provided by  GIO,
           the  TTY  interface  may  be  used directly, following a call to
           GSTATI to get the pointer to the TTY descriptor for the device.
           
           The boolean function GGETB tests  whether  the  device  has  the
           named  capability.   The  integer  and  real functions GGETI and
           GGETR return the capability value  as  the  function  value,  or
           zero  if  the  capability is not defined for the device.  String
           valued  capabilities  are  returned  by  GGETS  as   an   output 
           argument;  the  null  string  is returned if the device does not
           have the indicated capability.
       
       
       g[sg]view (gp, x1, x2, y1, y2)
           
           pointer gp              # graphics descriptor
           real    x1, x2          # range of NDC coordinates in X
           real    y1, y2          # range of NDC coordinates in Y
           
           Set or get the NDC coordinates of the viewport  associated  with
           the  current WCS.  The default viewport is the full display area
           of the device.
       
       
       g[sg]wind (gp, x1, x2, y1, y2)
           
           pointer gp              # graphics descriptor
           real    x1, x2          # range of world coordinates in X
           real    y1, y2          # range of world coordinates in Y
           
           Set or get the world coordinates of the window  associated  with
           the  current WCS.  The default window ranges from 0 to 1 in both
           X and Y,  i.e.,  the  default  window  associates  a  normalized
           coordinate  system  with  the  associated  viewport.  Any window
           limits passed as INDEF  will  be  ignored,  i.e.,  those  window
           parameters will not be modified.
       




                                    -23-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       g[ar]scale (gp, v, npts, axis)
           
           pointer gp              # graphics descriptor
           real    v[npts]         # data vector window is to be scaled to
           int     npts            # length of data vector
           int     axis            # axis to be scaled (1=X, 2=Y).
           
           Set  absolute  (GASCALE)  or  rescale  (GRSCALE) the minimum and
           maximum world coordinates of the indicated axis of  the  current
           window,  i.e.,  scale  the  window to fit a data vector.  May be
           called repeatedly if overplotting several curves.   The  current
           minimum  and  maximum  values for either axis may be obtained at
           any time by calling GGWIND.   To  scale  the  window  to  fit  a
           family  of  curves, call GASCALE for the first curve and GRSCALE
           for the remaining curves, thereby computing the range in  X  and
           or Y of all curves.
       
       
       ggscale (gp, x, y, dx, dy)
           
           pointer gp              # graphics descriptor
           real    x, y            # point at which scale is desired (wc)
           real    dx, dy          # scale, wcs units per ndc unit
           
           Determine  the  scale  in  world  coordinate  units at the point
           (x,y).  Useful for computing the size  of  an  object  in  world
           coordinates  given  its  size in ndc coordinates, or vice versa.
           An approximation is used to determine the scale if  log  scaling
           is  in  use.   Note that the scale is a function of position for
           the nonlinear coordinate systems.
       
       
       gctran (gp, x1, y1, x2, y2, wcs1, wcs2)
           
           pointer gp              # graphics descriptor
           real    x1, y1          # input point in WCS1 coords
           real    x2, y2          # output point in WCS2 coords
           int     wcs1, wcs2      # input, output world coordinate systems
           
           Transform a point in  world  coordinate  system  WCS1  to  world
           coordinate  system  WCS2.  If WCS1 is zero the transformation is
           from NDC coordinates to WCS coordinates.  If WCS2  is  zero  the
           transformation  is  from  WCS  coordinates  to  NDC coordinates.
           Otherwise the transformation is between two user  defined  world
           coordinate   systems.   The  point  need  not  fall  within  the 
           viewports of the two world coordinate systems.  World coordinate
           systems which were never set are equivalent to WCS=0.
       









                                    -24-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gcurpos (gp, x, y)
           
           pointer gp              # graphics descriptor
           real    x, y            # current pen position in world coordinates
           
           Return   the   "current  pen  position"  in  the  current  world 
           coordinate system.  The current pen  position  is  the  position
           set by the last move or draw command.
       
       
       gescape (gp, fn, instruction, nwords)
           
           pointer gp              # graphics descriptor
           int     fn              # function code
           short   instruction[nwords]     # instruction sequence to be passed
           int     nwords          # length of instruction sequence
           
           Send  a  device  dependent  instruction sequence to the graphics
           kernel.  Escape functions are ignored by  GIO  and  by  graphics
           kernels that do not recognize the function code.
   
   
   
   3.9.4 OUTPUT PROCEDURES
   
       Data  passed  to  the  polyline  or polymarker output procedures may
   contain embedded INDEF (indefinite) values in the X,  Y,  or  V  arrays.
   Indefinite  valued  points  appear  as  gaps in the plot and are ignored
   when autoscaling.  Indefinite valued pixels are not permitted in a  cell
   array since GIO does not look at the values of the pixels.
   
   
       
       glabax (gp, title, xlabel, ylabel)
           
           pointer gp              # graphics descriptor
           char    title[ARB]      # plot title
           char    xlabel[ARB]     # X axis label
           char    ylabel[ARB]     # Y axis label
           
           Draw  and  label  the  axes of the viewport.  If the WCS has not
           yet been fixed it will be  fixed  by  this  call.   If  desired,
           GLABAX  may modify the window slightly to place simple values on
           the  tick  marks.   Numerous  GSET  options  are  available  for 
           controlling  the  number and sizes of the tick marks, the format
           of tick labels, the axes on which tick  labels  appear,  and  so
           on.   If  the  device  viewport  has  not  yet been set and axis
           labelling is enabled, GLABAX will set a  default  size  viewport
           which allows room for the label text outside the viewport.
       







                                    -25-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gline (gp, x1, y1, x2, y2)
           
           pointer gp              # graphics descriptor
           real    x1, y1          # start of line
           real    x2, y2          # end of line
           
           Draw  a  line  connecting the point (x1,y1) to the point (x2,y2)
           (WCS coordinates).  The linetype, linewidth, and  color  may  be
           changed   beforehand   with   a  call  to  GSET.   The  relevant 
           parameters and their possible values are shown below.   Linetype
           zero  (clear)  may  be used to erase lines drawn with any of the
           other linetypes (device permitting).
           
                   G_PLTYPE        0=clear, 1=solid, 2=dashed, 3=dotted,
                                       4=dotdash, >4=device dependent
                   G_PLWIDTH       relative line width (default 1.0)
                   G_PLCOLOR       color index
       
       
       gpline (gp, x, y, npts)
           
           pointer gp              # graphics descriptor
           real    x[npts]         # X coordinates of the line endpoints
           real    y[npts]         # Y coordinates of the line endpoints
           int     npts            # number of line endpoints
           
           Polyline.  Draw a line connecting the points (WCS  coordinates).
           The  linetype,  linewidth,  and  color may be changed beforehand
           with a call to GSET.
       
       
       gvline (gp, v, npts, x1, x2)
           
           pointer gp              # graphics descriptor
           real    v[npts]         # vector to be plotted (Y values)
           int     npts            # number of line endpoints
           real    x1, x2          # range of vector in X 
           
           Vector polyline.  Draw a polyline wherein the Y  values  of  the
           polyline   are  taken  from  V  and  the  X  values  are  evenly 
           distributed along the X-axis, ranging from X1 at point  V[1]  to
           X2 at point V[npts] (WCS coordinates).
       
       
       gmark (gp, x, y, marktype, xsize, ysize)
           
           pointer gp              # graphics descriptor
           real    x, y            # WCS coordinates of marker
           int     marktype        # marker type
           real    xsize, ysize    # marker sizes
           
           Mark  drawing  primitive.  Draw a mark of type MARKTYPE and size
           MARKSIZE at the given position in WCS coordinates.   The  marker
           type  codes  recognized  are  shown  below  and  are  defined in
           <gset.h>.  Marktype  codes  may  be  summed  to  make  composite


                                    -26-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           marks, e.g.,
           
                   call gmark (gp, x, y, GM_PLUS+GM_CROSS, 1.)
           
           is  an  asterisk.   The pseudo-mark GM_FILL may be combined with
           GM_CIRCLE, GM_BOX, or GM_DIAMOND to output the mark as a  filled
           area,  using  the  current  fill  area  attributes.   A positive
           MARKSIZE specifies the mark size  in  NDC  coordinates,  whereas
           negative  signifies WCS coordinates.  The positive marksizes 1.,
           2., 3., and 4. signify default size marks of increasing size.
           
               typecode      name                symbol
           
                   0       GM_POINT        smallest plottable point
                   1       GM_FILL         fill interior of mark
                   2       GM_BOX          square box
                   4       GM_PLUS         plus
                   8       GM_CROSS        cross
                  16       GM_DIAMOND      diamond
                  32       GM_HLINE        horizontal line
                  64       GM_VLINE        vertical line
                 128       GM_HEBAR        horizontal error bar
                 256       GM_VEBAR        vertical error bar
                 512       GM_CIRCLE       circle
           
           The linetype for a mark is set by the  parameter  G_PMLTYPE.   A
           mark  may  be  erased  (device permitting) by setting the marker
           linetype to clear and redrawing the mark.  The color index  used
           for marks is controlled by the GSET parameter G_PMCOLOR.
       
       
       gpmark (gp, x, y, npts, marktype, xsize, ysize)
           
           pointer gp              # graphics descriptor
           real    x[npts]         # WCS X coordinates of markers
           real    y[npts]         # WCS Y coordinates of markers
           int     npts            # number of markers
           int     marktype        # marker type
           real    xsize, ysize    # marker sizes
           
           Polymarker.   Plot  a  sequence of NPTS markers at the positions
           given by  successive  WCS  coordinate  pairs  (x[i],y[i]).   All
           markers  will be of the same type and size.  The significance of
           the marker type and size codes is the same as for GMARK.
       
       
       gvmark (gp, v, npts, x1, x2, marktype, xsize, ysize)
           
           pointer gp              # graphics descriptor
           real    v[npts]         # WCS Y coordinates of markers
           int     npts            # number of markers
           real    x1, x2          # range of WCS X coordinates
           int     marktype        # marker type
           real    xsize, ysize    # marker sizes
           


                                    -27-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           Vector polymarker.  Plot a  sequence  of  NPTS  markers  at  the
           positions  given by successive WCS coordinate pairs (x[i],y[i]),
           where the x[i] are evenly distributed from X1 at V[1] to  X2  at
           V[npts].   All  markers  will be of the same type and size.  The
           significance of the marker type and size codes is  the  same  as
           for GMARK.
       
       
       gumark (gp, x, y, npts, xcen, ycen, xsize, ysize, fill)
           
           pointer gp              # graphics descriptor
           real    x[npts],y[npts] # normalized polyline defining marker
           int     npts            # number of points in polyline
           real    xcen, xcen      # world coordinates of center of marker
           real    xsize, ysize    # marker size in X and Y
           int     fill            # draw mark using area fill
           
           Draw  a  user  defined  marker.   The  marker  is defined by the
           polyline  (X[i],Y[i]),  normalized  to  the  unit  square.   The 
           marker  polyline  is  scaled  to fit the window defined by XCEN,
           YCEN, XSIZE, and YSIZE, where the center is  always  defined  in
           world  coordinates but the marker sizes may be defined in any of
           a number of ways (see GMARK).  If FILL is YES  the  marker  will
           be drawn using area fill rather than as a polyline.
       
       
       g[ar]move (gp, x, y)
           
           pointer gp              # graphics descriptor
           real    x, y            # WCS coordinates to move or shift
           
           Move  absolute (GAMOVE) or move relative (GRMOVE), with the "pen
           up".  A move relative should be preceded by a move  absolute  to
           unambiguously   define   the   "current  pen  position"  in  WCS 
           coordinates.  Only the move, draw,  and  mark  primitives  leave
           the  pen in a defined position.  Calls to GSET may be intermixed
           with move and draw commands without affecting  the  current  pen
           position.
       
       
       g[ar]draw (gp, x, y)
           
           pointer gp              # graphics descriptor
           real    x, y            # WCS coordinates to move or shift
           
           Move  absolute (GADRAW) or move relative (GRDRAW), with the "pen
           down".  Draws a line segment.  The type of line drawn  (linetype
           or   "pen   number")  defaults  to  solid  but  may  be  changed 
           beforehand  with  a  call  to  GSET.   Calls  to  GSET  may   be 
           intermixed  with  move  and  draw commands without affecting the
           current pen position.
       





                                    -28-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gtext (gp, x, y, text, format)
           
           pointer gp              # graphics descriptor
           real    x, y            # WCS coordinates of text string
           char    text[ARB]       # text to be plotted
           char    format[ARB]     # text characteristics
           
           Plot the string TEXT at the position (x,y) in  WCS  coordinates.
           The   default   size,  orientation,  and  justification  of  the 
           generated string  may  be  set  by  a  prior  call  to  GSET  or
           overridden  for  the  duration of the current call by the FORMAT
           string.  A null format string is permtted.
           
           
                     keyword               values                 default
           
                   up              degrees ccw, zero = +x          90
                   size            character size scale factor     1.0
                   path            left,right,up,down              r
                   hjustify        normal,center,left,right        l
                   vjustify        normal,center,top,bottom        b
                   font            roman,greek,italic,bold         r
                   quality         normal,low,medium,high          n
                   color           integers greater than one       1
           
           
           The attributes controlling  how  text  is  generated  are  shown
           above.   The  character  up  vector  (attribute  UP) defines the
           horizontal  and  vertical   axes   (the   horizontal   axis   is 
           perpendicular  to the character up vector).  Directions left and
           right, up and down are relative to these  axes.   The  attribute
           PATH  defines  the  direction  in  which  characters  are  to be
           plotted.  The attribute QUALITY  makes  it  possible  to  choose
           between   low   or   medium  quality  (fast)  and  high  quality 
           (expensive)  character  generation  techniques,  e.g.,  hardware 
           versus   software   character  generation.   This  attribute  is 
           normally best set to "normal" and then  overridden  at  metafile
           translation time.
           
           The  attributes  are  set  in  the  format string by a semicolon
           delimited list of  keyword=value  constructs.   Only  the  first
           character  of  keyword  and  value strings is significant, i.e.,
           keywords and values may be  abbreviated  to  as  little  as  one
           character  if  desired.  For example, the format "p=d;v=c" would
           plot characters downward in a vertical string  centered  at  the
           position given.
           
           The  default  font is set by the font attribute at the beginning
           of each call.  Font changes may also  be  signalled  by  placing
           the  sequence  "\fF"  in  the  text,  where  F  is  one  of  the 
           characters RGIB, denoting the fonts roman,  greek,  italic,  and
           bold.   In  this  manner  the  font may change from character to
           character within a  single  line  of  text.   Additional  escape
           sequences may be added to represent special symbols.
       


                                    -29-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       gfill (gp, x, y, npts, style)
           
           pointer gp              # graphics descriptor
           real    x[npts]         # X coordinates of polygon
           real    y[npts]         # Y coordinates of polygon
           int     npts            # number of vertices of polygon
           int     style           # type of fill
           
           Area  fill.   The  points (x[i],y[i]) define a closed area which
           will be filled in the indicated  STYLE.   The  recognized  style
           codes, defined in <gset.h>, are:
           
                   0       GF_CLEAR        clear area
                   1       GF_HOLLOW       draw only outline of area
                   2       GF_SOLID        fill area with a color
                  3-6      GF_HATCH[1234]  fill area with a pattern
                  7-N                      device dependent
           
           If  the  device  can support multiple colors the color index for
           area fill may be set beforehand with a call to GSET to  set  the
           parameter G_FILLCOLOR.
       
       
       gpcell (gp, m, nx, ny, x1, y1, x2, y2)
           
           pointer gp              # graphics descriptor
           short   m[nx,ny]        # greylevels or colors (pixels)
           int     nx, ny          # number of pixels in X and Y
           real    x1, y1          # lower left corner of output area
           real    x2, y2          # upper right corner of output area
           
           Output  a  cell  array.   Map each pixel in the input array into
           the corresponding  area  of  the  output  device.   For  maximum
           efficiency  the resolution of M should match that of the area of
           the output device defined by the  window  (x1,y1)  and  (x2,y2),
           otherwise  M is subsampled or replicated to best fill the output
           area.  The aspect ratio of a pixel need not be preserved in  the
           mapping.   The  pixel  values  (greylevels or color indices) are
           passed on to the kernel without modification.
       
       
       gscur (gp, x, y)
           
           pointer gp              # graphics descriptor
           real    x, y            # new cursor position
           
           Move  the  device  cursor  to  the   indicated   position   (WCS 
           coordinates).
   
   
   
   3.9.5 INPUT PROCEDURES
   
       Input  procedures are available for cursor and pixel input.  Inquiry
   of GIO parameters and device capabilities is handled by  the  GSTAT  and


                                    -30-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   GGET procedures and is not considered graphics input.
   
   
       
       clgcur (param, wx, wy, wcs, key, strval, maxch)
           
           char    param[ARB]      # CL parameter to be input
           real    wx, wy          # world coordinates of cursor event
           int     wcs             # index of WCS selected
           int     key             # keystroke value of cursor event
           char    strval[maxch]   # string value if set option (key = ':')
           int     maxch           # max chars to be returned in strval
           
           The  next  value of the list structured CL cursor type parameter
           PARAM is read and  the  cursor  coordinates  in  WCS  units  are
           decoded  and  returned  as  output arguments, along with the WCS
           number and the keystroke value, i.e.,  the  character  typed  by
           the  user causing the cursor to be read.  The range of keystroke
           values  is  the  full  ASCII  character  set,  minus  a   system 
           dependent  subset  of  control  codes  (if  a physical cursor is
           read, the read is always terminated by the user typing a key  on
           the  user  terminal).   No  GIO  device need be open to read the
           cursor.  EOF is returned as the function value when the  end  of
           the  cursor  list  is  reached.   The number of output arguments
           successfully decoded is returned as the  function  value  for  a
           normal read.  Values not converted are set to zero.
       
       
       ggcur (gp, sx, sy, key)
           
           pointer gp              # graphics descriptor
           real    sx, sy          # NDC coordinates of cursor event
           int     key             # keystroke value of cursor event
           
           The  physical  cursor  of  the  graphics  device associated with
           graphics descriptor GP is read and  the  cursor  coordinates  in
           NDC  units  are  returned  as  output  arguments, along with the
           keystroke value, i.e., the  character  typed  or  button  pushed
           causing  the cursor to be read.  On many devices the cursor read
           will be instantanenous (the cursor position  will  be  sampled),
           and  the  keystroke  value  will  always  be zero.  The range of
           possible keystroke values is device dependent.  EOF is  returned
           as  the  function  value  when  the  end  of  the cursor list is
           reached.  An  error  action  is  taken  if  the  device  is  not
           readable.   The GIO device must have previously been opened with
           GOPEN.
           
           Use of this low level procedure  is  not  recommended  since  it
           forces  a  program to be used interactively, operation is device
           dependent, and cursor mode interaction is  not  supported.   The
           main  uses  for  GGCUR  are  cursor  input from special graphics
           devices, i.e., devices other  than  STDGRAPH  or  STDIMAGE,  and
           continuous  sampling  of  the  cursor  position on devices which
           support it.  The  characteristics  of  the  device  cursors  are
           described in the graphcap entry for the device.


                                    -31-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       ggcell (gp, m, nx, ny, x1, y1, x2, y2)
           
           pointer gp              # graphics descriptor
           short   m[nx,ny]        # output pixel array
           int     nx, ny          # number of pixels out in X and Y
           real    x1, y1          # lower left corner of input area
           real    x2, y2          # upper right corner of input area
           
           Input  a  cell array.  The cell array defined by the rectangular
           window from point (x1,y1) to (x2,y2) is  read  into  the  output
           array  M of size NX columns by NY lines.  For maximum efficiency
           the resolution of the output array  should  match  that  of  the
           device  area  defined by the input window.  If the resolution of
           the output array does not match that of the device output  lines
           will  be  subsampled or replicated to best fit the output array.
           Unaddressable pixels are returned as negative values.  An  error
           action is taken if the device is not readable.
   
   
   
   3.10 GIO INTERNAL PARAMETERS
   
       The  GIO  internal parameters may be set with either a GSET or GSCAN
   call,  and  inspected  with  a  GSTAT  function  call.   Parameters  are 
   identified  to  GSET and GSCAN by an integer code.  Each integer code is
   assigned a symbolic name  of  the  form  G_PARAM  in  the  include  file
   <gset.h>.   In  input  to  GSCAN,  parameters are referred to by name in
   lower case, without the "g_" prefix.  The parameters and  their  default
   values are shown below.
   
   
           PARAMETER     DEFAULT            DESCRIPTION
   
           wcs             1       index of current WCS
           xtran           linear  linear, log, or nlog (WCS attribute)
           ytran           linear  linear, log, or nlog (WCS attribute)
           clip            yes     clip at viewport boundary (WCS attribute)
           cursor          1       current cursor number
           pltype          1       polyline linetype
           plwidth         1.0     polyline relative line width
           plcolor         1       polyline color index
           pmltype         1       polymarker linetype
           pmcolor         1       polymarker color index
           szmarker[1-4] (.5:2)*ch standard marker sizes, NDC coordinates
           fastyle         1       fill area interior style
           facolor         1       fill area color index
           txsize          1.0     relative character size
           txup            90      character up vector
           txpath          right   direction in which characters are drawn
           txspacing       0.0     character spacing relative to height
           txhjustify      left    horizontal justification (n,c,l,r)
           txvjustify      bottom  vertical justification (n,c,t,b)
           txfont          roman   text font (roman,greek,italic,bold)
           txquality       normal  text generator precision (n,l,m,h)
           txcolor         1       text color index


                                    -32-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



               (axis labelling parameters)
   
           drawtitle       yes     draw plot title if given
           titlesize       1.0     character size for plot title
           titlejust       center  horizontal justification of title
           ntitlelines     1       number of lines in title block
           aspect          0.0     aspect ratio of viewport (0=dontcare)   
   
               (the following are duplicated for the Y axis)
   
           xdrawaxes       3       draw X axis 1, 2, both (3), none (0)
           xsetaxispos     no      set world coords of X axes
           xaxispos1       0.0     world coord of X axis 1 (default wx1)
           xaxispos2       0.0     world coord of X axis 2 (default wx2)
           xdrawgrid       yes     draw grid marks connecting X ticks
           xround          no      extend WCS to end at a tick mark
           xlabelaxis      yes     draw axis label string if given
           xaxislabelsize  1.0     character size for X axis label
           xdrawticks      yes     draw and label X ticks
           xlabelticks     yes     label X ticks
           xnmajor         6       number of major ticks in X
           xnminor         4       number of minor ticks in X
           xmajorlength    0.8ch   length of a major tick, X
           xminorlength    0.4ch   length of a minor tick, X
           xmajorwidth     1.0     linewidth of a major tick, X
           xminorwidth     1.0     linewidth of a minor tick, X
           xaxiswidth      1.0     linewidth of the axis
           xticklabelsize  1.0     character size for X tick labels
           xtickformat     ""      override format for X tick labels
   
               (read only variables)
   
           tty             -       pointer to TTY graphcap descriptor
           fd              -       file descriptor of output stream
           devname         -       device name as passed to gopen
   
   
   The  Y  axis  parameters have names equivalent to those shown with the X
   prefix replaced by a Y.  If the prefix  is  omitted  entirely  then  the
   parameters  for  both  axes will be set or queried.  The GLABAX code and
   parameters are built  upon  the  GIO  graphics  primitives  and  may  be
   replaced by a more sophisticated user program if desired.
   
   Drawing and labelling of the X and Y axes is parameterized independently
   in X and Y.  If drawing and labelling  of  an  axis  is  disabled,  tick
   drawing  and labelling is automatically disabled.  Drawing and labelling
   of an axis may be disabled on only one  side  of  the  viewport  (useful
   when  a  single  viewport is used simultaneously for two different world
   coordinate systems).  If tick drawing  is  disabled  tick  labelling  is
   automatically  disabled.   The tick marks, if drawn, may be connected by
   dotted lines within the interior of the plot.
   
   Given the approximate number  of  major  ticks,  GIO  will  compute  the
   nearest  number  of  tick  marks resulting in round numbers for the tick
   mark labels.  If rounding is enabled the window will be enlarged to  the


                                    -33-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   nearest  tick  outward  on either end of an axis, otherwise an axis will
   end at the window boundary, which need not fall  on  a  tick  mark.   If
   linear  scaling  is  indicated  NMINOR minor ticks will be drawn between
   each pair of major ticks.  If log scaling is indicated  the  NMAJOR  and
   NMINOR  parameters  are ignored and major ticks will be placed at powers
   of ten with eight minor ticks (e.g., 2,3,4,5,6,7,8,9) between each  pair
   of  major  ticks.   Tick  lengths  are  given  in  NDC coordinates.  The
   default tick lengths are parameterized in terms of the character  height
   for the device.
   
   
   
   
   3.11 GRAPHCAP PARAMETERS
   
       Each  logical  graphics  device accessible to GIO must have an entry
   in the GRAPHCAP (graphics capabilities) file.  The name  of  the  device
   entry  in  the graphcap file must agree with that specified in the GOPEN
   call when the device is opened.  Multiple logical device entries may  be
   given  for  a  single  physical  device,  each  with  slightly different
   parameters.  The name of the graphcap file is parameterized  by  the  CL
   environment  variable  "graphcap",  making  it  easy  for  the  user  to 
   customize or extend the graphcap file.  The graphcap entries for  common
   devices  may  be  precompiled  by  the  system  manager to eliminate the
   overhead of searching the graphcap file at run time.
   
   The format of the graphcap file is identical to that of a  UNIX  TERMCAP
   file,  and  indeed the same interface (TTY) is used to access both types
   of files.  The set of capabilities defined  for  a  graphics  device  is
   however  quite different than that defined for a terminal.  Capabilities
   are typed parameters referred to by a two character internal name.   The
   restriction  to  two  characters is perhaps unfortunate but is desirable
   for efficiency reasons (as well as for compatiblity  with  the  original
   termcap)  and  may  be alleviated at some point in the future by the use
   of macro defines.
   
   Graphcap parameters fall into two classes, those  parameters  which  are
   common  to all devices, and those parameters which are required only for
   devices accessed with a particular graphics kernel.  GIO is  capable  of
   supporting  any  number  of  quite  different kernels, each of which may
   support any number of devices.  These kernels are free to add parameters
   to  their  graphcap  entries  provided  they  do  not  conflict with the
   standard parameters.  An example  is  the  "fast"  or  STDGRAPH  kernel,
   discussed  in  detail in a later section.  If a device is to be accessed
   by more than  one  kernel  each  kernel  must  typically  have  its  own
   graphcap  entry  for  the  device,  with selection of the graphcap entry
   (logical device name) specifying the kernel to be used.
   
   In the discussion which follows the reader  is  assumed  to  already  be
   familiar  with  the  syntax  and usage of TERMCAP format files.  This is
   documented, for example, in section 5 of the  UNIX  manuals.   A  sample
   termcap  entry  for  the  devices "vt100-nam" and "vt100-am" is included
   below as an example of a typical termcap entry.
   
   


                                    -34-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   d1|vt100|vt100-nam|vt100 w/no am:\
           :am@:xn@:tc=vt100-am:
   d0|vt100|vt100-am|vt100|dec vt100:\
           :cr=^M:do=^J:nl=^J:bl=^G:co#80:li#24:cl=50\E[;H\E[2J:\
           :le=^H:bs:am:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:\
           :ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
           :md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
           :rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:\
           :if=/usr/lib/tabset/vt100:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:\
           :ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:ta=^I:pt:sr=5\EM:vt#3:xn:\
           :k5=\EOp:k6=\EOx:k7=\EOr:k8=\EOm:k9=\EOl:k0=\EOq:\
           :sc=\E7:rc=\E8:cs=\E[%i%d;%dr:ks=\E[?1h\E=:ke=\E[?1l\E>:
   
   
   Note that each device  may  be  known  by  several  names.   The  device
   capabilities  are  delimited  by  colons,  e.g., ":xx=...:yy=...:".  The
   special capability  "tc"  allows  an  entry  to  include  another  entry
   recursively.   Escape is represented as either "\E" or "^[", <ctrl/h> is
   "^H".   If  a  delay  of  so  many  milliseconds   is   required   after 
   transmission  of  a  string,  the  number of milliseconds appears as the
   first few chars in an entry, e.g.,  "cl=50..."  causes  a  delay  of  50
   milliseconds   following  a  screen  clear.   Numeric  capabilities  are 
   prefaced by a sharp, e.g., ":co#80:" (screen has 80 columns).
   
   
   
   
   3.11.1 GENERIC GRAPHCAP PARAMETERS
   
       To make the distinction between  the  generic  and  kernel  graphcap
   parameters  clear and to eliminate the possibility of redefinitions, the
   generic parameters have lower case names and the kernel parameters  have
   upper  case  names.   Only  the  standard  graphcap parameters should be
   accessed from within applications  programs.   The  standard  parameters
   are  listed  and  defined below.  These parameters should be included in
   the graphcap entry for every device.
   
   
       ar   real      Aspect ratio dY/dX, i.e., the ratio of  the  size  of
                      the  device  screen  in Y to that in X (equivalent to
                      ys/xs).
       
       ca   bool      Device implements  cellarray  plotting  in  hardware,
                      i.e,  the ZR greylevels are displayed by the hardware
                      rather than emulated by software in the kernel.
       
       ch   real      Height in NDC units of a character of size 1.0.
       
       co   int       Number of columns of text displayable on  the  device
                      screen at character size 1.0.
       
       cw   real      Width in NDC units of a character of size 1.0.
       




                                    -35-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       fa   bool      Device implements fill area in hardware.
       
       fs   int       Number of fill area styles supported by the device.
       
       in   bool      Device  supports  at  least one input function, i.e.,
                      cursor readback or cell array input.
       
       k1   int       Minimum possible key value in a cursor read.
       
       k2   int       Maximum possible key value in a cursor read.
       
       kf   str       Filename of the executable graphics kernel  file  for
                      the  device.  If this is given as "cl", the kernel is
                      assumed to be resident in the CL process.  Should  be
                      a  virtual  filename,  e.g.,  "dev$x_device.e".   See 
                      also parameter TN.
       
       li   int       Number of lines of text  displayable  on  the  device
                      screen at character size 1.0.
       
       lt   int       Number of linetypes supported by the device.
       
       lw   int       Number of linewidths supported by the device.
       
       nc   int       Number of cursors supported by the device.
       
       nk   int       Number of possible key values in a cursor read.
       
       pl   bool      Device implements polyline drawing in hardware.
       
       pm   bool      Device implements polymarker drawing in hardware.
       
       ro   bool      Device  supports  roam at the hardware level (used in
                      cursor mode).
       
       se   bool      Device supports selective erase of  portions  of  the
                      screen.
       
       tf   int       Number of text fonts supported by the device.
       
       th   int       Number  of  text  heights  or  sizes supported by the
                      device.   If  absent  or  zero  it  is  assumed  that 
                      characters  may  be freely scaled in size.  If only a
                      number of discreet character sizes are available  the
                      sizes are given by the parameters TN.
       
       tn   str       Taskname,  i.e.,  name of the logical task within the
                      kernel file KF to be run to exercise a kernel.
       
       tq   int       Number of text quality or precision levels  supported
                      by the device.
       





                                    -36-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       tN   real      Sizes  of  the  TH possible character sizes, relative
                      to a character of size 1.0 (expands  to  the  set  of
                      parameters t1,t2,...,tN).
       
       tx   bool      Device implements text generation in hardware.
       
       wc   bool      Reading  the  cursor  implies  a wait, i.e., a cursor
                      read is triggered by the user.
       
       xr   int       Device resolution in X.
       
       xs   real      Device scale in X, i.e., the  width  of  the  display
                      area in meters.
       
       yr   int       Device resolution in Y.
       
       ys   real      Device  scale  in  Y, i.e., the height of the display
                      area in meters.
       
       zo   bool      Device supports zoom at the hardware level  (used  in
                      cursor mode).
       
       zr   int       Device   resolution   in   Z,  i.e.,  the  number  of 
                      greylevels or colors displayable at each point  using
                      the cell array primitive.
   
   
   The  graphcap  parameters  are  accessed  by  name  via GGET calls.  For
   example,
   
           xr = ggetr (gp, "xr")
   
   would assign the value of the parameter "xr" into the local variable  of
   the same name.
   
   
   
   3.11.2 STDGRAPH GRAPHCAP PARAMETERS
   
       The  STDGRAPH kernel is the "fast" kernel, i.e., the graphics kernel
   resident in the CL process.  This kernel is capable  of  driving  almost
   any  modern  graphics  terminals  given  only  a  graphcap entry for the
   device, providing the graphics terminal  is  data  driven  and  provides
   both character and vector generation in hardware.
   
   
   
   3.11.2.1 CLASSES OF PARAMETERS
   
       The stdgraph parameters fall into a number of classes which we shall
   describe separately.  An  alphabetical  summary  of  all  parameters  is
   given in a later section.
   
   The  open  and  close  workstation  sequences  are  sent  to  the device
   whenever the workstation is activated (OW) or  deactivated  (CW),  e.g.,


                                    -37-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   when  the  STDGRAPH  kernel  receives  the  open  workstation  or  close 
   workstation directive,  or  when  the  open  workstation  is  explicitly
   deactivated and later reactivated by the applications program.
   
   The  primary  function of the open and close workstation sequences is to
   effect a mode switch from text mode to graphics  mode  and  back  again,
   but   the   sequences  may  also  contain  instructions  used  only  for 
   initialization or mode setting.  For example, OW might  initialize  user
   defined  line  types  or enable the graphics board.  The close string CW
   might disable the graphics board and set the alpha cursor to a  standard
   place on the screen.
   
   The graphics enable and disable strings (GE,GD) are sent to the terminal
   by the STDGRAPH kernel when status line i/o  occurs.   The  GD  sequence
   should  clear the status line, leaving the terminal in status line mode,
   with the text cursor positioned to the start of the  status  line.   The
   GE  sequence  restores  the  terminal to graphics mode, and is often the
   same as the OW sequence.  Note that GD should  not  cause  the  graphics
   frame  to disappear, as the status line is supposed to be visible at the
   same time as the plot.
   
   The status line is normally the line at the bottom of  the  screen.   On
   terminals  with  separate  text  and graphics memories which can both be
   displayed at the same time, the status line  is  normally  written  into
   the  text  memory.   If the terminal has both text and graphics memories
   but can only display one at a time the graphics memory should  be  used,
   provided  the  status line can be erased in the graphics memory.  If the
   graphics plane must  be  used  but  erase  is  not  possible,  the  best
   approach  is  probably  to write successive lines of status line text on
   top of the plot,  starting  at  the  upper  left  corner  and  advancing
   downward   for  each  line  of  output  text  (see  the  4012  entry  in 
   dev$graphcap).
   
   The parameters X1, X2, Y1, and Y2 define the range of device coordinates
   to  be  output.  Normally these will span the full screen of the device,
   but in general they may define any  rectangular  window  on  the  device
   screen.   The  fill  area  and  font  tables are array valued parameters
   mapping the GKI fill area and font indices into  device  codes  (if  the
   device should happen to support such niceties).
   
   
           OW              open (reactivate) workstation
           IF              initialization file, if OW string is large
           CW              close (deactivate) workstation
           GE              graphics enable (exit status line mode)
           GD              graphics disable (enter status line mode)
           CL              screen clear
           LR              load registers (see "binary encoding")
   
           X1,X2           range of device X coordinates
           Y1,Y2           range of device Y coordinates
   
   
   The  set  attribute  parameters  are  format  strings used to encode set
   attribute commands, each of which has a single  integer  argument.   The


                                    -38-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   format  string is similar to a PRINTF format string with the addition of
   a notation for binary encoding (described below).
   
   
           TH(i)           set text height
           TC(i)           set text color
           TF(i)           set text font
           LT(i)           set line type
           LC(i)           set line color
           LW(i)           set line width
           MC(i)           set marker color
           FT(i)           set fill area type
           FC(i)           set fill area color
   
   
   Polyline  generation,  i.e.,  vector  drawing,  is  more  difficult   to 
   parameterize.   We  assume that polylines, polymarkers, fill areas, etc.
   are all similar enough to be described by the same  coordinate  encoding
   format,  but  we  allow each such instruction to have different head and
   tail strings.
   
           PL              polyline flag
           VS              move start
           VE              move end
           DS              draw start
           DE              draw end
           MS              marker start
           ME              marker end
           FS              fillarea start
           FE              fillarea end
           XY(i,j)         coord format
   
   
   A polyline command consists of a number of subcommands, as  outlined  in
   the  drawing  below.   The  polyline  is  a move followed by one or more
   draws.   The  polyline  flag  PL  is  set  to  indicate  that   multiple 
   coordinate  pairs  can  be output between the DS and DE commands.  If PL
   is false (or omitted) each coordinate pair in the GKI polyline  will  be
   output  surrounded  by  DS  and  DE  commands.   The  encoding  of  each 
   coordinate pair is defined by the parameter XY.
   
   
           set attributes if necessary
           move start
               x, y
           move end
           draw start
               x, y
                   ...
               x, y
           draw end
   
   
   The polymarker and fillarea parameters are optional.   The  kernel  will
   emulate  markers and fill area if not supported by the hardware.  Recall


                                    -39-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   that GIO handles all mark drawing except GM_POINT  (point  mode),  hence
   sophisticated mark drawing facilities are not required.
   
   Text  generation  is  handled  by  the kernel a character at a time.  If
   character up is 90 degrees and the path is  to  the  right,  the  kernel
   will  assume  that it can output a number of characters between a TS and
   a TE.  Otherwise each character will be output  preceded  by  a  TS  and
   followed  by  a  TE.   The  TS  parameter  is  a  format string with two
   arguments, the device coordinates  of  the  lower  left  corner  of  the
   character  to be drawn.  The encoding of these coordinates is defined by
   the  TS  format  string.   It  is  possible  to  perform  a   coordinate 
   transformation   using  the  binary  encoding  facilities,  if  such  is 
   necessary.  If characters are not addressed at the lower left corner  an
   offset may be applied to the given coordinates using the binary encoding
   facilities.
   
   
           TS(i,j)         text start
           TE              text end
   
   
   Cursor output is controlled  by  the  parameter  WC.   Cursor  input  is
   initiated  by  output  of the sequence defined by the format RC.  RC has
   one integer argument, the number of the  cursor  to  be  read.   The  UC
   capability,  if  defined,  will  cause the cursor position to be updated
   (with WC) to the position at the last cursor read.   This  is  desirable
   if  the  device  cannot maintain the cursor position, i.e., if unrelated
   graphics output commands affect the cursor position as an unwanted  side
   effect.
   
   
           UC              update cursor pos before read
           WC(x,y,i)       write cursor 
           RC(i)           read cursor start
           RE              read cursor end
           CN              cursor value length
           CD              cursor value delimiter
           SC              scan cursor (-> x,y,key)
   
   
   Following  transmission  of  the  RC  sequence  the kernel will read the
   response as defined by the parameters CN and CD.  At least one of CN  or
   CD  must be given.  If CN is given but not CD exactly CN characters will
   be read.  If CD  is  given  then  characters  will  be  read  until  the
   delimiter  string is matched (and until at least CN characters have been
   read).  If possible a delimiter string should  be  specified  to  permit
   recovery  from  bad  cursor  reads,  e.g., when the user types something
   before the cursor is displayed.  When  a  satisfactory  cursor  response
   string  has  been  obtained  the  format  SC  will be used to decode the
   string into the output values  X,  Y,  and  KEY.   The  RE  sequence  is
   transmitted once the cursor read has successfully completed.
   
   
   



                                    -40-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.11.2.2 BINARY ENCODING
   
       Graphics  devices  vary  widely  in  the  techniques  used to encode
   numeric data such as a line type  or  color  index,  or  the  coordinate
   pairs  of  a  polyline.   Our  approach  to  the  encoding  problem is a
   generalization of the PRINTF format string.  The encoder is driven by  a
   format  string  taken  from the graphcap entry for the device.  A number
   of standard formats are recognized  with  encoding  provided  internally
   for  these  standard  formats  by  the  encoder.   To permit encoding of
   special formats the encoder provides a very general  yet  efficient  RPN
   virtual  machine  capable  of computing bit patterns according to a user
   supplied program embedded in the format string.
   
   A format string is a sequence of ASCII characters.  Any ASCII character,
   including  all  control  characters,  is  permitted  in the string.  The
   significance of a character depends on the context in which it  appears.
   Initially  characters  are  simply  copied to the output.  Three special
   characters  are  recognized  in  COPY  MODE  (excluding  the  characters 
   already counted as special by termcap):
   
   
           '       escape next character (literal)
           %       begin a formatted output string
           (       begin an executable expression
   
   
   The  encoder  is  a  table driven interpreter which is programmed by the
   format given in the graphcap file.  Programming the  encoder  is  rather
   like  programming  in  assembler or microcode (its fun but easy to screw
   up).  The encoder provides a set of 12  integer  registers,  an  integer
   stack  with a capacity of 50 values, and a dozen or so instructions.  It
   is fundamentally assumed that  the  character  set  is  ASCII  (this  is
   guaranteed by the IRAF programming environment).
   
   Upon  entry  one or more of the registers 1 through 3 are initialized to
   the values of the input  arguments,  leaving  the  remaining  registers,
   i.e.,  R4-R9  and R0 (R10) available for general use.  Registers R11 and
   R12 are reserved for internal use.  The interpreter  is  activated  when
   an  unescaped  (  is  encountered  in  the  input.   In EXECUTE MODE the
   following characters have special  meanings  (excluding  :,  ^,  and  \,
   which are special characters to termcap/TTY):
   















                                    -41-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           '       escape next character (recognized everywhere)
           %       conventional formatted output
           )       revert to copy mode
           #nnn    push signed decimal integer number nnn
           $       switch case construct
           .       pop number from stack and place in output string
           ,       get next character from input string and push on stack
           &       modulus (similar to AND of low bits)
           +       add (similar to OR)
           -       subtract (similar to AND)
           *       multiply (shift left if pwr of 2)
           /       divide (shift right if pwr of 2)
           <       less than (0=false, 1=true)
           >       greater than (0=false, 1=true)
           =       equals (0=false, 1=true)
           ;       branch if: <bool> <offset> ;.  The ; is at offset=0.
          0-9      push contents of register 0 through 9
           !N      pop stack into register N
           !!      generate a N millisecond delay, where N is on the stack
   
   
   Any  other  character  encountered  in execute mode is interpreted as an
   integer number and pushed on the stack.  Hence,  the  character  "@"  is
   equivalent  to  "#64", i.e., octal 100.  A blank is the integer constant
   40B.
   
   The output format directive % will format and output the number  on  the
   top  of  the  stack,  popping  the  stack  in  the  process.  The format
   specification may be any legal PRINTF format.   The  case  construct  is
   used  to  process  set  attribute  commands, e.g., set linetype 0, 1, 2,
   text size 1, 2, 3, etc, and  also  provides  a  rudimentary  conditional
   processing  capability.  The branch if operator ; provides a rudimentary
   branching and looping capability.  Beware that sequences like  "^N"  and
   "\E" compile as a single character in the format string.
   
   
   
   3.11.2.3 EXAMPLES
   
       As a simple example consider the encoding of the ANSI command to set
   the cursor of a nongraphics terminal.   The  required  sequence  is  the
   following:
   
           ESC [ line ; col H
   
   Assuming  that  the column number is designated as X and the line number
   as Y, in registers 1 and 2 respectively, the format would be as  follows
   (the quotes are not part of the format):
   
           "\E[(2)%d;(1)%dH"
   
   Now  assume that the output sequence is the same but the line and column
   numbers  are  one-indexed  while  the  terminal  requires   zero-indexed 
   coordinates:
   


                                    -42-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           "\E[(2#1-)%d;(1#1-)%dH"
   
   Thus  far  the  examples have been pretty trivial and do not warrant the
   complexity of the RPN interpreter proposed here.  For our  next  example
   consider  the  encoding  of  a  polyline coordinate pair for a Tektronix
   compatible graphics terminal and for  an  AED512,  two  quite  different
   graphics   terminals.   The  Tektronix  format  for  encoding  an  (X,Y) 
   coordinate pair is as follows:
   
   
           0 1 YA Y9 Y8 Y7 Y6
           1 1 Y5 Y4 Y3 Y2 Y1
           0 1 XA X9 X8 X7 X6
           1 0 X5 X4 X3 X2 X1
   
   
   Since the Tektronix device  is  so  common  the  special  format  %t  is
   provided  for  encoding  register  1 and 2 (X and Y) in this format, and
   writing out the result.  The format string
   
           "%t"
   
   is all that is required.  The more general solution is provided  by  the
   following format.
   
           "(2 / +.2 &`+.1 / +.1 &@+."
   
   To  understand  this  last  example one must look up the octal values of
   the characters " " (40B), "`" (140B), and "@" (100B).  The  notation  is
   admittedly  rather  cryptic  but  it  is also concise and efficient, and
   works for a wide range of devices.
   
   Now consider the AED512 in binary mode (this is courtesy of NCAR;  I  do
   not  have  access  to  such  a  terminal).   The  output  encoding  of a
   coordinate pair is as follows:
   
   
           XA X9 X8 YB YA Y9 Y8
           X7 X6 X5 X4 X3 X2 X1
           Y7 Y6 Y5 Y4 Y3 Y2 Y1
   
   
   The format required to generate this is shown below.  Note  the  use  of
   register  9  to  store  the constant 200B.  The "^N" signifies <ctrl/n>,
   i.e., 16B, used to effect a left shift of four bits.
   
           "(#128!919/^N*29/+.19&.29&."
   
   This format could be further  optimized  by  preloading  register  9  at
   OPENWS  time  by  moving  the  "(#128!9"  to  parameter LR.  The encoder
   registers  maintain  their  values  indefinitely.   Using  LR  the   two 
   parameters might appear in the graphcap entry as follows.
   
           ":LR=(#128!9:XY=(19/^N*29/+.19&.29&.:"
   


                                    -43-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   The  case  construct  makes it possible to generate output conditionally
   based on the  value  of  an  integer  switch.   The  syntax  of  a  case
   statement is as follows:
   
           $1 ... $2-5 ... $6 ... $D ... $$
   
   When the first $ is encountered the switch value is popped off the stack
   and converted into a character by addition of the  constant  '0'  (60B).
   The  interpreter  will  then  scan  forward until it finds the indicated
   case, at which  point  it  resumes  execution  in  case  mode.   If  the
   indicated  case is not found scanning will stop at $D (the default case)
   or $$, whichever comes first.  When the next $ is seen  the  interpreter
   skips  forward until it finds $$, which marks the end of the case.  Case
   constructs are not nestable.
   
   The case construct is used primarily for  set  attribute  formats.   For
   example,  the  GKI  linetype codes are integers greater than or equal to
   zero, with case zero being the line clear and  the  other  cases  actual
   linetypes.   For the VT640 there are nine possible linetypes, i.e., line
   clear, five builtin  linetypes,  and  3  user  defined  linetypes.   The
   strings to be output for the cases 0 through 5 are the following:
   
   
           linetype                     string
   
               0                   ESC / 1 d ESC `
               1                   ESC / 0 d ESC `
               2                   ESC / 0 d ESC a
               3                   ESC / 0 d ESC b
             (etc)                      (etc)
   
   
   We  could  encode linetypes 0, 1 through 5, and everything else with the
   following format (linetype code in register 1):
   
           "\E/(1$0)0d\E`($1-5)1d\E(1_+.$D)0d\E`($$"
   
   Note that case searching is a  simple  string  matching  operation  that
   ignores  operators  such  as  (  and ).  Only $, ' (escape), and EOS are
   recognized when searching for a case.
   
   
   
   3.11.2.4 EFFICIENCY
   
       The interpreter approach to solving  the  general  encoding  problem
   presented here is not the only solution to the problem.  Before adopting
   this  approach  several  alternatives   were   considered.    One   such 
   alternative  was  the bitfield packing and unpacking scheme used by NCAR
   to solve the same problem.  The  third  alternative  considered  was  to
   hand  code  a  subroutine  for  each  encoding required for each device.
   Benchmarks run to compare the three alternatives yielded  the  following
   times  in cpu seconds required to plot a 1000 point array with Tektronix
   encoding:
   


                                    -44-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           bitfields       approximately 30 seconds
           interpreter     0.82 - 2.0 seconds
           hand coded      0.78 seconds (mostly i/o)
   
   
   The time required for character output is included in the figures shown.
   The bitfields benchmark is an extrapolation from an actual timing of the
   prototype NCAR software as ported to the UNIX VAX by Cliff  Stoll.   The
   GBYTE  and  SBYTE  primitives  used  to  implement bitfields in the NCAR
   software were written in portable C by Cliff and did  not  use  the  VAX
   bitfield  instructions, which would have helped significantly (but which
   would not have yielded a fair test: all IRAF  target  machines  may  not
   have  bitfield instructions).  The two timings shown for the interpreter
   are for the  "%t"  format  and  the  general  format.   The  clock  time
   required  by the hardware (VT100 with VT640 retrographics board) to draw
   the vectors was about 7 seconds.
   
   We conclude that the execution time  overhead  of  the  interpreter  for
   encoding  polyline  points  is  acceptable  and  the  use of hand coded,
   device dependent procedures is neither  warranted  nor  desirable.   The
   bitfields technique is too inefficient to use in a production interface.
   
   
   
   3.11.2.5 DECODING CURSOR INPUT
   
       Decoding  of  the cursor value string returned by the device into X,
   Y, and KEY (keystroke) values is carried  out  using  the  table  driven
   interpreter  for  decoding  rather  than  for  encoding.   In  this mode
   characters are input with "," and the decoded output values  X,  Y,  and
   KEY  are  returned  in  registers  1  through  3.  The % format encoding
   operator is not used.  If the cursor value is returned in ASCII X and  Y
   must  be  converted  to  binary the hard way (e.g., "ch1 '0' - 100 * ch2
   '0' - 10 * +", etc.).
   
   To verify that this scheme will work consider the cursor value  returned
   by  a  Tektronix compatible terminal.  The return value is 6 characters,
   consisting of the character typed followed by the encoded  X  and  Y  in
   the next four characters, and lastly a CR terminator:
   
   
           C7 C6 C5 C4 C3 C2 C1
            0  1 XA X9 X8 X7 X6
            0  1 X5 X4 X3 X2 X1
            0  1 YA Y9 Y8 Y7 Y6
            0  1 Y5 Y4 Y3 Y2 Y1
            0  0  0  1  1  0  1
   
   
   The required decoding format is shown below.
   
           ",!3, & *, &+!1, & *, &+!2"
   
   
   


                                    -45-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.11.2.6 SUMMARY OF STDGRAPH GRAPHCAP PARAMETERS
   
       An  alphabetical  summary  of  the  graphcap  parameters used by the
   STDGRAPH kernel is given below.
   
   
           CD              cursor value delimiter
           CL              screen clear
           CN              cursor response length
           CW              close (deactivate) workstation
           DE              draw end
           DS              draw start
           FC(i)           set fill area color
           FE              fillarea end
           FS              fillarea start
           FT(i)           set fill area type
           GD              graphics disable (exit status line mode)
           GE              graphics enable (enter status line mode)
           IF              initialization file, if OP string is large
           LC(i)           set line color
           LR              load registers
           LT(i)           set line type
           LW(i)           set line width
           MC(i)           set marker color
           ME              marker end
           MS              marker start
           OW              open (reactivate) workstation
           PL              polyline flag
           RC(i)           read cursor start
           RE              read cursor end
           SC              scan cursor (-> x,y,key)
           TC(i)           set text color
           TE              text end
           TF(i)           set text font
           TH(i)           set text height
           TS(i,j)         text start
           VE              move end
           VS              move start
           WC(x,y,i)       write cursor 
           X1              first device X coordinate
           X2              last device X coordinate
           XY(i,j)         coordinate format
           Y1              first device Y coordinate
           Y2              last device Y coordinate
   
   
   As a final example, the actual graphcap entry  for  the  vt640  terminal
   (DEC VT100 with retrographics) is reproduced below.
   
   







                                    -46-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   vt640|vt640g|vt100 with Retrographics:\
       :RC=(1$2)^X\E[24;65H\E[7mLIGHT PEN READY\E[0m($$)^]\E"(1$2)5($D)4($$)g:\
       :WC=^]%t\E/f:OW=150^]^_:CW=^X\E[24;0H\E[K:GE=150^]^_:GD=^X\E[24;0H\E[K:\
       :lt#5:nc#2:se:CL=50^]\E^L:xr#640:yr#480:ar#.57:xs#.23:ys#.13:tc=4012:
   
   4012|tek4012|tektronix 4012:\
       :ar#.70:ch#.0294:co#80:cw#.0125:in:k1#1:k2#127:kf=cl:li#35:\
       :lt#5:nc#1:nk#127:pl:pm:th#4:t1#1:t2#2:t3#3:t4#4:tx:\
       :wc:xr#1024:yr#780:xs#.20:ys#.14:\
       :CD=^M:CN#6:LT=^]\E/(1$0)1d\E`($1-5)0d\E(1_+.$D)0d\E`($$:\
       :MS=\034:PL:RC=\E^Z:SC=(,!3, & *, &+!1, & *, &+!2:\
       :TH=\E(1#47+.:TS=^]%t^_:VS=^]:X1#0:X2#1023:XY=%t:Y1#0:Y2#779:\
       :OW=^]^_:CW=(#682!2#0!1)^]%t^_:GE=^]^_:\
       :CL=1000(#32!9)\E^L:\
       :LR=(#32!9:GD=(9#1-!99$0#31!9$$9#22*!2#0!1)^]%t^_:
   
   
   
   3.11.3 TERMCAP AND GRAPHCAP
   
       Every  graphics  terminal  entry  in the graphcap file should have a
   corresponding terminal capability entry in the termcap file.   When  the
   user  sets  the  terminal type with the STTY task in the CL, the termcap
   entry tells whether or not the terminal supports  vector  graphics,  and
   the  value  of  the STDGRAPH environment variable is set to "none" for a
   non-graphics terminal, or to the graphcap  name  of  the  device  for  a
   graphics  terminal.   For a terminal to be recognized by the system as a
   graphics terminal the termcap entry must include the  ":gd"  capability.
   If  the  graphcap name for the device is different than the termcap name
   then the form ":gd=gcname:" should be used.
   
   For example, the minimal termcap entry for the vt640  graphics  terminal
   would  be  as  follows.  Note that it makes no sense to set the terminal
   type to  "vt100",  since  a  standard  vt100  does  not  support  vector
   graphics.
   
           vt640|Retrographics enhanced VT100:\
           :gd:tc=vt100:
   
   The  "gd"  capability  is  not  standard termcap, but will be ignored by
   non-IRAF programs which do not recognize the capability.
   
   
   
   3.12 GRAPHICS KERNEL INTERFACE
   
       The graphics kernel interface (GKI) is  the  interface  between  GIO
   and  the  underlying  graphics  kernel  or  kernels.   The GKI is a data
   driven interface, i.e., GIO communicates with the  graphics  kernel  via
   bidirectional   streams   of   control   instructions   and  data.   The 
   functionality assumed by the GKI is simple enough to  permit  use  of  a
   variety   of   graphics  kernels,  e.g.,  the  builtin  GIO  kernel  for 
   interactive  graphics  terminals,  GKS,  CORE,  NSPP,  and  so  on.   To 
   understand  the level of functionality expected from the kernel we first
   summarize the functions the kernel is NOT  expected  to  perform,  i.e.,


                                    -47-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   the functions performed by GIO before output to the kernel:
   
   
       o   All  WCS coordinate transformations and clipping at the viewport
           boundary.  The kernel sees only NDC coordinates.
       
       o   Axis drawing and labelling.  GIO processes a GLABAX call into  a
           sequence of polylines in NDC coordinates.
       
       o   Mark  drawing.   GIO  processes  all  mark drawing commands into
           polyline instructions.
       
       o   Move  and  draw  commands.   GIO  processes  all  absolute   and 
           relative  move  and  draw  commands  into  sequences of polyline
           instructions.
   
   
   The main functions of the kernel  are  the  control  and  attribute  set
   functions,  set  cursor,  polyline,  polymarker  (GM_POINT  only),  text 
   generation, fill area, cell array, and cursor read.  A kernel  need  not
   implement  all such functions, but it must at least recognize and ignore
   the corresponding GKI instructions.  The  GKI  kernel  instructions  are
   easily  implemented for modern intelligent graphics terminals.  The fast
   kernel will  let  the  terminal  handle  polyline  drawing,  point  mode
   polymarker drawing, dashed lines, and character generation.
   
   The  GKI  format  is  a  sequence  of variable length binary control and
   output instructions.  Each instruction  consists  of  the  beginning  of
   instruction  sentinel  (BOI),  an  integer binary opcode identifying the
   instruction,  an  integer  giving  the  length  of  the  instruction  in 
   metacode  words,  and  an  arbitrary number of parameter and data words.
   The BOI word  aids  in  the  detection  of  and  recovery  from  botched
   instructions, e.g., if an interrupt occurs while writing an instruction.
   
   
            FIELD                          DESCRIPTION
   
           BOI             beginning of instruction (magic value = 100000B)
           opcode          unique instruction identification code (1-27)
           length          length of entire of instruction in metacode
                               words (includes all four fields)
           data            variable length part of instruction
   
                       Figure 3. GKI Instruction Format
   
   
   The  instruction  format chosen for GKI is basically a direct mapping of
   the required low level functions into binary opcodes.  Various  standard
   formats  were  considered  and  rejected,  in  particular  the  GKS  VDM 
   (virtual device metafile) format.  GKS VDM  turned  out  to  be  far  to
   complex  to  be  worth  using  at this level in the system.  The GKS VDI
   format might  have  been  better  suited,  but  I  could  not  find  any
   information  describing this format (my understanding was that, although
   there are numerous implementations of VDI, there is no  formal  standard
   as yet).


                                    -48-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   The  GKI format may be extended at some point in the future to provide a
   binary instruction for each procedure in the GKS Fortran binding.   This
   will  make  it  possible  for  applications  to  use  either GIO or GKS,
   provided a GKS kernel is available.  This will make it easier to  import
   applications  which  are  already  written  to  use GKS (alternatively a
   mini-GKS might be built upon GIO,  since  the  primitive  functions  are
   almost  identical).   Since  IRAF  itself  is  transportable  and  it is
   desirable for IRAF applications to have full  access  to  the  IRAF  i/o
   facilities,  new  IRAF applications are not being written with transport
   to another data reduction system in mind.  New  IRAF  applications  will
   use  only  GIO  whenever  the  facilities  provided by GIO are adequate.
   Applications which use only GIO will continue  to  be  usable  with  any
   graphics kernel.
   
   
   
   3.12.1 GKI INSTRUCTIONS
   
       The  GKI  instruction  stream  transmitted  between processes on the
   same or compatible machines will be a  sequence  of  SPP  short  integer
   metacode  words.   The  machine  independent GKI metafile format will be
   the equivalent stream encoded as 16 bit twos complement  signed  integer
   metacode  words,  blocked  1440 words per block, with conversion between
   the internal and external metacode formats being provided  by  the  IRAF
   MII  (machine  independent  integer)  interface  (MII takes care of byte
   swapping, etc.).  GKI metafiles in MII format will be  easily  read  and
   written  by  different  machines,  offloading  most  of  the work to the
   graphics kernel on the reader machine.  The GKI  instruction  format  is
   designed  for  maximum  efficiency  on  modern  minicomputers, i.e., the
   internal format (SPP short integer) is an atomic  datatype  and  no  bit
   operations are required to generate or interpret metacode.
   
   NDC  coordinates  (0.0 to 1.0) will be represented in GKI as integers in
   the range 0-32767.  Character data  will  be  packed  one  7  bit  ASCII
   character  per  metacode  word.   Floating  point  is  required only for
   certain output attributes, e.g.,  the  linewidth  and  character  height
   (size)  scale  factors.   To  avoid  the  problems  of machine dependent
   floating point  formats  we  shall  represent  the  low  precision  real
   numbers  by  converting  them to integer metacode words scaled according
   to the following relation:
   
           I = int (R * 1E2)
   
   Specifications for the GKI metafile instructions follow.   The  datatype
   and  size of each field of the instruction is given in parenthesis.  The
   datatype "p" denotes a coordinate pair (x,y) of type  (m,m),  where  "m"
   denotes an NDC coordinate.
   
   The  OPENWS  instruction  marks  the  start  of an instruction stream or
   METAFILE for a particular device.  A  subsequent  CLOSEWS  (or  physical
   end  of  file)  marks  the  end of a metafile.  An OPENWS in APPEND mode
   requires that GIO recall the  WCS  defined  when  the  device  was  last
   accessed.   A  physical  file  may  consist of any number of independent
   metafiles.  Although there is no explicit connection between OPENWS  and
   screen  clear (CLEARWS), a screen clear is implied for some devices when


                                    -49-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   opened in new file mode.  The MFTITLE instruction  is  optional  and  is
   provided only for documenting the contents of a metafile.
   
   
                           GKI_EOF = BOI  0 L
                        GKI_OPENWS = BOI  1 L M N D
                       GKI_CLOSEWS = BOI  2 L N D
                  GKI_REACTIVATEWS = BOI  3 L
                  GKI_DEACTIVATEWS = BOI  4 L
                       GKI_MFTITLE = BOI  5 L N T
                       GKI_CLEARWS = BOI  6 L
                        GKI_CANCEL = BOI  7 L
                         GKI_FLUSH = BOI  8 L
                      GKI_POLYLINE = BOI  9 L N P
                    GKI_POLYMARKER = BOI 10 L N P
                          GKI_TEXT = BOI 11 L P N T
                      GKI_FILLAREA = BOI 12 L N P
                  GKI_PUTCELLARRAY = BOI 13 L LL UR NC NL P
                     GKI_SETCURSOR = BOI 14 L CN POS
                         GKI_PLSET = BOI 15 L LT LW CI
                         GKI_PMSET = BOI 16 L MT MW CI
                         GKI_TXSET = BOI 17 L UP SZ SP P HJ VJ F Q CI
                         GKI_FASET = BOI 18 L FS CI
                     GKI_GETCURSOR = BOI 19 L CN
                   GKI_CURSORVALUE = BOI 19 L CN POS KEY
                  GKI_GETCELLARRAY = BOI 20 L LL UR NC NL
                     GKI_CELLARRAY = BOI 20 L NP P
                        GKI_ESCAPE = BOI 25 L FN N DC
                        GKI_SETWCS = BOI 26 L N WCS
                        GKI_GETWCS = BOI 27 L N
   
                           The GKI Instruction Set
   
   
   
   3.12.1.1 CONTROL INSTRUCTIONS
   
       The  NULL  instruction  is  unique  in  that it consists of a single
   metacode word with value zero.  The BOI and length fields  are  omitted.
   Any  number  of  null  words  may  be  inserted between regular metacode
   instructions, e.g., to pad a block of metacode to be written to  an  MII
   format  metafile.  The EOF instruction is used internally by GIO to stop
   metacode translation on a pseudofile stream, as if end of file had  been
   encountered.
   
   The  open  workstation  instruction  should start a new frame unless the
   access mode is APPEND, in which case graphics is  to  be  added  to  the
   last  frame.   An  OPENWS  implies an REACTIVATEWS.  CLOSEWS does little
   more than deactivate the workstation, since the last frame must in  some
   sense  remain  open  for APPEND mode to be possible.  Normal termination
   of the kernel process will or an open workstation in a mode  other  than
   append will cause the last frame to be terminated.
   
   
   


                                    -50-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       GKI_EOF = BOI 0 L
       
           L(i)            3
       
       
       GKI_OPENWS = BOI 1 L M N D
       
           L(i)            5 + N
           M(i)            access mode (APPEND=4, NEW_FILE=5, TEE=6)
           N(i)            number of characters in field D
           D(Nc)           device name as in GRAPHCAP file
       
       
       GKI_CLOSEWS = BOI 2 L N D
       
           L(i)            4 + N
           N(i)            number of characters in field D
           D(Nc)           device name as in GRAPHCAP file
       
       
       GKI_REACTIVATEWS = BOI 3 L
       
           L(i)            3
       
       
       GKI_DEACTIVATEWS = BOI 4 L
       
           L(i)            3
       
       
       GKI_MFTITLE = BOI 5 L N T                                 (optional)
       
           L(i)            4 + N
           N(i)            number of characters in field T
           T(Nc)           title string identifying metafile
       
       
       GKI_CLEARWS = BOI 6 L
       
           L(i)            set to the constant 3 (no data fields)
       
       
       GKI_CANCEL = BOI 7 L
       
           L(i)            set to the constant 3 (no data fields)
       
       
       GKI_FLUSH = BOI 8 L
       
           L(i)            set to the constant 3 (no data fields)
   
   
   




                                    -51-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   3.12.1.2 OUTPUT INSTRUCTIONS
   
       All   data   points   in  the  GKI  output  instructions  have  been 
   transformed into NDC coordinates and clipped at  the  viewport  boundary
   (if  clipping  is enabled).  In the process GIO will translate any INDEF
   valued points by breaking large polylines into smaller polylines,  hence
   the  semantics  of plotting polylines and polymarkers is quite simple at
   the graphics kernel level.
   
   CELLARRAY is processed into a  series  of  one  dimensional  cell  array
   instructions,  one  for  each line in the two dimensional array supplied
   by the user.  Fewer or shorter lines  will  be  output  if  clipping  is
   necessary.   Arrays  larger  than  32767 pixels may be output since each
   line is passed as a separate instruction.  The maximum number  of  lines
   and  columns  in  a  cell  array  is 32767 and 32761, respectively (more
   lines can be input but they  will  not  be  resolved).   The  kernel  is
   expected  to  scale  cell  arrays  to  fit  the  output  device via some
   combination of pixel replication or subsampling, if there is not  a  one
   to one correspondence between cell array pixels and device pixels.
   
   
       GKI_POLYLINE = BOI 9 L N P
       
           L(i)            4 + N * 2
           N(i)            number of points in the polyline
           P(Np)           list of points (x,y pairs)
       
       
       GKI_POLYMARKER = BOI 10 L N P
       
           L(i)            4 + N * 2
           N(i)            number of points in the polymarker
           P(Np)           list of points (x,y pairs)
       
       
       GKI_TEXT = BOI 11 L P N T
       
           L(i)            6 + N
           P(p)            starting point of character string
           N(i)            number of characters in string T
           T(Nc)           string of N ASCII characters
       
       
       GKI_FILLAREA = BOI 12 L N P
       
           L(i)            4 + (N * 2)
           N(i)            number of points defining the polygon to be filled
           P(Np)           list of points (x,y pairs)
       
       







                                    -52-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       GKI_PUTCELLARRAY = BOI 13 L LL UR NC NL P
       
           L(i)            9 + (N * M)
           LL(p)           coordinates of lower left corner of output area
           UR(p)           coordinates of upper right corner of output area
           NC(i)           number of columns in array
           NL(i)           number of lines in array
           P(NCNLi)        array of color indices (pixels) stored by row
       
       
       GKI_SETCURSOR = BOI 14 L CN POS
       
           L(i)            6
           CN(i)           cursor number
           POS(p)          new cursor position
   
   
   
   3.12.1.3 SET ATTRIBUTE INSTRUCTIONS
   
       The set polyline, polymarker, text, and fillarea instructions change
   the attributes used to generate  graphics  output.   These  instructions
   need  be issued only when one of the attributes in an instruction packet
   changes, i.e., the kernel is assumed to remember the attributes while  a
   device is open.
   
   
       GKI_PLSET = BOI 15 L LT LW CI
       
           L(i)            6
           LT(i)           linetype number
           LW(r)           linewidth scale factor
           CI(i)           polyline color index
       
       
       GKI_PMSET = BOI 16 L MT MW CI
       
           L(i)            6
           MT(i)           marktype (not used at present)
           MW(i)           marksize, NDC coords (not used at present)
           CI(i)           marker color index
       
       
       GKI_TXSET = BOI 17 L UP SZ SP P HJ VJ F Q CI
       
           L(i)            12
           UP(i)           character up vector (degrees)
           SZ(r)           character size scale factor
           SP(r)           character spacing
           P(i)            path (0,2=left,3=right,4=up,5=down)
           HJ(i)           horizontal justification
                               (0=normal,1=center,2=left,3=right)
           VJ(i)           vertical justification
                               (0=normal,1=center,6=top,7=bottom)
           F(i)            font (8=roman,9=greek,10=italic,11=bold)


                                    -53-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           Q(i)            quality (0=normal,12=low,13=medium,14=high)
           CI(i)           text color index
       
       
       GKI_FASET = BOI 18 L FS CI
       
           L(i)            5
           FS(i)           fill style (0=clear,1=hollow,2=solid,3-6=hatch)
           CI(i)           fill area color index
   
   
   The  attributes for the output primitives are assumed to be set to their
   default values when OPENWS is issued.
   
   
   
   3.12.1.4 INPUT INSTRUCTIONS
   
       The primary input instruction is the cursor read  instruction,  used
   to  read the cursor position in NDC coordinates.  The device cursor read
   may be either event driven or instantaneous.   If  the  cursor  read  is
   event  driven  a  nonzero  keystroke value may be returned, the range of
   possible keystroke values being  device  dependent.   The  instantaneous
   type  of  cursor  read is preferred at the GKI level since it offers the
   maximum flexibility (CLGCUR may then be  used  to  provide  an  optional
   device   independent  keystroke  driven  cursor  read).   Devices  which 
   support both forms of cursor read may provide both as  separate  logical
   cursors.   The  graphics kernel should return a null cursor value if the
   output device does not have a cursor.
   
   
       GKI_GETCURSOR = BOI 19 L CN
       
           L(i)            4
           CN(i)           cursor number
           
           The kernel reads graphics  cursor  number  CN  and  returns  the
           keystroke  value  (if  any)  and  the  cursor  position  in  NDC 
           coordinates.   The  cursor  attributes  are  returned   in   the 
           following format:
           
                   GKI_CURSORVALUE = BOI 19 L CN POS KEY
           
           where
           
                   L(i)            7
                   CN(i)           cursor number
                   POS(r)          NDC coordinates of cursor
                   KEY(i)          keystroke value (>= 0 or EOF)
       
       






                                    -54-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



       GKI_GETCELLARRAY = BOI 20 L LL UR NC NL
       
           L(i)            9
           LL(p)           coordinates of lower left corner of input area
           UR(p)           coordinates of upper right corner of input area
           NC(i)           number of columns in output array
           NL(i)           number of lines in output array
           
           The   GETCELLARRAY   instruction   is   the   converse   of  the 
           PUTCELLARRAY instruction.  The cell array  is  returned  in  the
           following format:
           
                   GKI_CELLARRAY = BOI 20 L NP P
           
           where
           
                   L(i)            4 + NP
                   NP(i)           number of pixels (0 if noread)
                   P(NPi)          array of pixels
       
       
       (instruction codes 19-24 are reserved for future use)
   
   
   
   3.12.1.5 ESCAPE INSTRUCTION
   
       The  escape instruction is used to pass device dependent information
   or commands to the graphics kernel via GKI.  The  graphics  kernel  will
   ignore  unrecognized escape functions.  Function codes 1 through 100 are
   reserved for use by GIO.
   
   
       GKI_ESCAPE = BOI 25 L FN N DC
       
           L(i)            5 + N
           FN(i)           escape function code
           N(i)            number of escape data words
           DC(i)           escape data words
   
   
   
   3.12.1.6 PSEUDO-GKI INSTRUCTIONS
   
       Since the CL must be able to read the device cursor and convert  NDC
   coordinates  to  WCS  coordinates, the WCS must be passed to the CL when
   they are "fixed" to the device.  The most natural and efficient  way  to
   do  this  is  via  the  GKI instruction stream, hence several additional
   instructions are used internally in GIO to communicate with the  portion
   of  GIO resident in the CL process.  These instructions are filtered out
   and executed by the CL process and  their  existence  may  therefore  be
   ignored by the graphics kernels.
   
   The  SETWCS  instruction  is  used  to  pass  WCS  information to the CL
   process.  The GETWCS instruction is used to recall the WCS for a  device


                                    -55-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   opened  in  APPEND  mode (the WCS are returned in SETWCS format).  Since
   these  instructions  are  passed  only  between  two   closely   coupled 
   processes  on a single cpu, floating point numbers are passed in machine
   dependent format.  The length of this instruction is machine  dependent.
   Only  the  fields  L  and  WCS  are  truely part of the instruction; the
   remaining fields are a binary copy of the GIO internal WCS structure.
   
   
       GKI_SETWCS = BOI 26 L N WCS
       
           L(i)            4 + 17 * sizeof (struct wcs)
           N(i)            length of WCS structure, words
           WCS             binary copy of the 17 WCS structures, transmitted
                               in a single call to WRITE
       
       
       GKI_GETWCS = BOI 27 L N
       
           L(i)            4
           N(i)            maximum number of words to read
   
   
   
   3.12.2 ENCODING GKI INSTRUCTIONS
   
       The GKI instruction opcodes and fields are  defined  in  the  global
   include  file lib$gki.h.  To avoid direct knowledge of the binary format
   of the GKI instructions, GIO uses a subpackage called GKI to encode  the
   GKI  instructions.  The GKI procedures each encode and transmit a single
   GKI instruction  on  the  output  stream.   Although  the  GIO  and  GKI
   procedures  have  similar  names,  they should not be confused.  The GIO
   GPLINE, for example, performs conversion from a WCS to  GKI  coordinates
   with  clipping  at  the  viewport  boundary,  checking that the polyline
   attributes  are  up   to   date   before   transmitting   the   polyline 
   instruction.   In  contrast  the  GKI  GKI_POLYLINE  merely  encodes and
   transmits the GKI_POLYLINE metacode instruction.
   
   The GKI procedures are self contained with  the  exception  of  the  set
   attribute  instructions,  which  reference  attribute  packet structures
   (argument AP) defined in the include file gio.h.   The  GKI  instruction
   encoding procedures are shown below.
   















                                    -56-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



                gki_openws (fd, device, mode)
               gki_closews (fd, device)
          gki_reactivatews (fd, flags)
          gki_deactivatews (fd, flags)
               gki_mftitle (fd, title)
               gki_clearws (fd)
                gki_cancel (fd)
                 gki_flush (fd)
              gki_polyline (fd, points, npts)
            gki_polymarker (fd, points, npts)
                  gki_text (fd, x, y, text)
              gki_fillarea (fd, points, npts)
          gki_getcellarray (fd, m, nx, ny, x1,y1, x2,y2)
          gki_putcellarray (fd, m, nx, ny, x1,y1, x2,y2)
                 gki_plset (fd, ap)
                 gki_pmset (fd, ap)
                 gki_txset (fd, ap)
                 gki_faset (fd, ap)
             gki_setcursor (fd, x, y, cursor)
             gki_getcursor (fd, x, y, key, cursor)
                gki_escape (fd, fn, instruction, nwords)
                gki_setwcs (fd, wcsdata, len_wcsdata)
                gki_getwcs (fd, wcsdata, len_wcsdata)
   
                gki_fflush (fd)    # not GKI instruction; flushes GKI stream
   
   
   
   
   3.12.3 DECODING GKI INSTRUCTIONS
   
       The  following  additional  procedures are provided for decoding and
   executing GKI metacode, e.g., in a graphics kernel.   In  what  follows,
   INSTRUCTION  is  a  short  integer  array  containing  the  encoded  GKI 
   instruction, and DD is the device driver table, i.e.,  array  of  ZLOCPR
   entry point addresses of the standard kernel procedures.
   
   
            stat = gki_fetch_next_instruction (fd, instruction_ptr)
                   gki_execute (instruction, dd)
                   gkp_install (dd, out_fd, verbose_output)
   
   
   The  FETCH  procedure  extracts  the  next  instruction  from  the input
   metacode stream, returning a short integer pointer  to  the  instruction
   as  an  output argument.  EOF is returned as the function value when end
   of file is detected.  The EXECUTE procedure decodes an  instruction  and
   calls  a  graphics  device  driver procedure to execute the instruction.
   If the entry point address of the driver procedure is  NULL  GKI_EXECUTE
   will  ignore  the  corresponding  GKI  instruction.   The  fields of the
   metacode instruction are passed to  the  driver  procedure  as  distinct
   arguments, hence the device driver need not understand the GKI format.
   
   A  standard  kernel  is provided for decoding GKI instructions, printing
   the decoded instructions in text form on the output stream.  The  driver


                                    -57-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   for  this  kernel is installed with GKP_INSTALL, setting the output file
   and verbose output flag in the process.
   
   
   
   3.12.4 EXAMPLE
   
       To illustrate the use of GKI as  well  as  the  output  of  the  GKI
   decoding  kernel, consider the simple GPLOTV style plot of the following
   function:
   
           y = x ** 2
   
   over the range
   
           x = 1 to 5, y = 1 to 25
   
   The decoded GKI metacode produced by  GIO  to  graph  this  function  is
   shown  below.   The "verbose" mode of output (shown) lists the values of
   the data points in the polyline,  etc.  output  functions.   If  verbose
   output   is  disabled  only  the  statistics  of  the  output  polylines 
   (computed by the decoder) will be printed.  All coordinates are  printed
   in  NDC  units.   The  redundant points appearing in the output metacode
   are expected to be filtered out by the kernel,  which  should  not  plot
   points separated by less than the device resolution in NDC units.
   
   
   open_workstation 'vt640', mode=new_file
   set_wcs nwords=352
            1 1. 5. 1. 25.  0.19 0.81 0.33 0.96  0 0 1
   set_polyline ltype=1, lwidth=2.00, color=1
   polyline np=3, xmin=0.19,xmax=0.19,xavg=0.19, ymin=0.33,ymax=0.37,yavg=0.34
           0.188 0.334  0.188 0.334  0.188 0.367  
   set_text up=90, path=right, hjustify=center, vjustify=top, font=roman,
           size=1.00, spacing=0.00, color=1, quality=normal
   text 0.19, 0.31, '1'
   polyline np=15, xmin=0.19,xmax=0.34,xavg=0.27, ymin=0.33,ymax=0.37,yavg=0.34
           0.188 0.334  0.219 0.334  0.219 0.350  0.219 0.334  0.250 0.334  
           0.250 0.350  0.250 0.334  0.281 0.334  0.281 0.350  0.281 0.334  
           0.313 0.334  0.313 0.350  0.313 0.334  0.344 0.334  0.344 0.367  
   text 0.34, 0.31, '2'
   polyline np=15, xmin=0.34,xmax=0.50,xavg=0.43, ymin=0.33,ymax=0.37,yavg=0.34
           0.344 0.334  0.375 0.334  0.375 0.350  0.375 0.334  0.406 0.334  
           0.406 0.350  0.406 0.334  0.437 0.334  0.437 0.350  0.437 0.334  
           0.469 0.334  0.469 0.350  0.469 0.334  0.500 0.334  0.500 0.367  
   text 0.50, 0.31, '3'
   polyline np=15, xmin=0.50,xmax=0.66,xavg=0.58, ymin=0.33,ymax=0.37,yavg=0.34
           0.500 0.334  0.531 0.334  0.531 0.350  0.531 0.334  0.562 0.334  
           0.562 0.350  0.562 0.334  0.593 0.334  0.593 0.350  0.593 0.334  
           0.625 0.334  0.625 0.350  0.625 0.334  0.656 0.334  0.656 0.367  
   text 0.66, 0.31, '4'
   polyline np=15, xmin=0.66,xmax=0.81,xavg=0.74, ymin=0.33,ymax=0.37,yavg=0.34
           0.656 0.334  0.687 0.334  0.687 0.350  0.687 0.334  0.718 0.334  
           0.718 0.350  0.718 0.334  0.750 0.334  0.750 0.350  0.750 0.334  
           0.781 0.334  0.781 0.350  0.781 0.334  0.812 0.334  0.812 0.367  


                                    -58-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



   text 0.81, 0.31, '5'
   polyline np=2, xmin=0.81,xmax=0.81,xavg=0.81, ymin=0.33,ymax=0.33,yavg=0.33
           0.812 0.334  0.812 0.334  
   polyline np=77, xmin=0.78,xmax=0.81,xavg=0.81, ymin=0.33,ymax=0.96,yavg=0.65
           0.812 0.334  0.812 0.334  0.796 0.334  0.812 0.334  0.812 0.360  
           0.796 0.360  0.812 0.360  0.812 0.386  0.796 0.386  0.812 0.386  
           0.812 0.412  0.796 0.412  0.812 0.412  0.812 0.438  0.779 0.438  
           0.812 0.438  0.812 0.464  0.795 0.464  0.812 0.464  0.812 0.490  
           0.795 0.490  0.812 0.490  0.812 0.516  0.795 0.516  0.812 0.516  
           0.812 0.542  0.795 0.542  0.812 0.542  0.812 0.568  0.779 0.568  
           0.812 0.568  0.812 0.594  0.795 0.594  0.812 0.594  0.812 0.620  
           0.795 0.620  0.812 0.620  0.812 0.646  0.795 0.646  0.812 0.646  
           0.812 0.672  0.795 0.672  0.812 0.672  0.812 0.698  0.779 0.698  
           0.812 0.698  0.812 0.724  0.795 0.724  0.812 0.724  0.812 0.750  
           0.795 0.750  0.812 0.750  0.812 0.776  0.795 0.776  0.812 0.776  
           0.812 0.802  0.795 0.802  0.812 0.802  0.812 0.828  0.778 0.828  
           0.812 0.828  0.812 0.854  0.795 0.854  0.812 0.854  0.812 0.880  
           0.795 0.880  0.812 0.880  0.812 0.906  0.795 0.906  0.812 0.906  
           0.812 0.932  0.795 0.932  0.812 0.932  0.812 0.958  0.778 0.958  
           0.812 0.958  0.812 0.958  
   polyline np=15, xmin=0.19,xmax=0.22,xavg=0.19, ymin=0.33,ymax=0.44,yavg=0.38
           0.188 0.334  0.188 0.334  0.204 0.334  0.188 0.334  0.188 0.360  
           0.204 0.360  0.188 0.360  0.188 0.386  0.204 0.386  0.188 0.386  
           0.188 0.412  0.204 0.412  0.188 0.412  0.188 0.438  0.221 0.438  
   set_text up=90, path=right, hjustify=right, vjustify=center, font=roman,
           size=1.00, spacing=0.00, color=1, quality=normal
   text 0.19, 0.44, '5'
   polyline np=15, xmin=0.19,xmax=0.22,xavg=0.19, ymin=0.44,ymax=0.57,yavg=0.51
           0.188 0.438  0.188 0.464  0.204 0.464  0.188 0.464  0.188 0.490  
           0.204 0.490  0.188 0.490  0.188 0.516  0.204 0.516  0.188 0.516  
           0.188 0.542  0.204 0.542  0.188 0.542  0.188 0.568  0.221 0.568  
   text 0.19, 0.57, '10'
   polyline np=15, xmin=0.19,xmax=0.22,xavg=0.19, ymin=0.57,ymax=0.70,yavg=0.64
           0.188 0.568  0.188 0.594  0.204 0.594  0.188 0.594  0.188 0.620  
           0.204 0.620  0.188 0.620  0.188 0.646  0.204 0.646  0.188 0.646  
           0.188 0.672  0.204 0.672  0.188 0.672  0.188 0.698  0.221 0.698  
   text 0.19, 0.70, '15'
   polyline np=15, xmin=0.19,xmax=0.22,xavg=0.19, ymin=0.70,ymax=0.83,yavg=0.77
           0.188 0.698  0.188 0.724  0.204 0.724  0.188 0.724  0.188 0.750  
           0.204 0.750  0.188 0.750  0.188 0.776  0.204 0.776  0.188 0.776  
           0.188 0.802  0.204 0.802  0.188 0.802  0.188 0.828  0.221 0.828  
   text 0.19, 0.83, '20'
   polyline np=15, xmin=0.19,xmax=0.22,xavg=0.19, ymin=0.83,ymax=0.96,yavg=0.90
           0.188 0.828  0.188 0.854  0.204 0.854  0.188 0.854  0.188 0.880  
           0.204 0.880  0.188 0.880  0.188 0.906  0.204 0.906  0.188 0.906  
           0.188 0.932  0.204 0.932  0.188 0.932  0.188 0.958  0.221 0.958  
   text 0.19, 0.96, '25'
   polyline np=2, xmin=0.19,xmax=0.19,xavg=0.19, ymin=0.96,ymax=0.96,yavg=0.96
           0.188 0.958  0.188 0.958  
   polyline np=65, xmin=0.19,xmax=0.81,xavg=0.50, ymin=0.92,ymax=0.96,yavg=0.95
           0.188 0.958  0.188 0.958  0.188 0.925  0.188 0.958  0.219 0.958  
           0.219 0.942  0.219 0.958  0.250 0.958  0.250 0.942  0.250 0.958  
           0.281 0.958  0.281 0.941  0.281 0.958  0.313 0.958  0.313 0.941  
           0.313 0.958  0.344 0.958  0.344 0.925  0.344 0.958  0.375 0.958  
           0.375 0.941  0.375 0.958  0.406 0.958  0.406 0.941  0.406 0.958  


                                    -59-
   GIO (Dec84)                   Graphics I/O                   GIO (Dec84)



           0.437 0.958  0.437 0.941  0.437 0.958  0.469 0.958  0.469 0.941  
           0.469 0.958  0.500 0.958  0.500 0.925  0.500 0.958  0.531 0.958  
           0.531 0.941  0.531 0.958  0.562 0.958  0.562 0.941  0.562 0.958  
           0.593 0.958  0.593 0.941  0.593 0.958  0.625 0.958  0.625 0.941  
           0.625 0.958  0.656 0.958  0.656 0.924  0.656 0.958  0.687 0.958  
           0.687 0.941  0.687 0.958  0.718 0.958  0.718 0.941  0.718 0.958  
           0.750 0.958  0.750 0.941  0.750 0.958  0.781 0.958  0.781 0.941  
           0.781 0.958  0.812 0.958  0.812 0.924  0.812 0.958  0.812 0.958  
   set_text up=90, path=right, hjustify=center, vjustify=bottom, font=roman,
           size=1.00, spacing=0.00, color=1, quality=normal
   text 0.50, 0.96, 'title'
   set_polyline ltype=1, lwidth=1.00, color=1
   polyline np=5, xmin=0.19,xmax=0.69,xavg=0.44, ymin=0.33,ymax=0.96,yavg=0.59
           0.188 0.334  0.313 0.412  0.438 0.542  0.562 0.724  0.687 0.958  
   flush
   close_workstation 'vt640'
   
   
   
   
   3.13 GRAPHICS KERNEL PARAMETERS
   
       The  translation  from  GKI  codes to device codes should ideally be
   parameterized to permit variable device resolution,  font  substitution,
   and  so  on  at  translation  time.   In general this is best handled by
   spooling the metacode and later processing it via an explicit call to  a
   metacode   translator  program,  using  CL  parameters  to  control  the 
   translation.  Some control over translation  may  also  be  achieved  by
   modifying  the GRAPHCAP entry for a device, provided the graphics kernel
   uses the graphics capability database.
   
   One of the  most  useful  translation  time  parameters  is  the  device
   resolution.   On  some devices, e.g. pen plotters, it is necessary to be
   able to change the device  resolution  at  translation  time  to  permit
   plotting  of  large  vectors  without  loss of resolution.  Changing the
   device resolution is also a valuable technique for speeding up  graphics
   when working remotely via a modem.
   
   
   
   4. GKS EMULATION
   
       The   basic   graphics   primitives   provided   by  GIO  (polyline, 
   polymarker, etc.) are functionally identical to those  provided  by  GKS
   (the  Graphics  Kernel System).  The basic drawing primitives of GKS are
   therefore easily emulated using GIO.  A subset of  the  Fortran  binding
   of  GKS  has already been emulated, sufficient to run the NCAR utilities
   recently converted by NCAR for use with GKS.  In principle it should  be
   possible  to  expand  the  GKS  emulation  to  a  full  level  0b  or 1b
   interface, although we have no plans to do so at present.
